\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{QVector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{;}
\PYG{n}{a}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{l+m+mi}{100000}\PYG{p}{);}\PYG{+w}{ }\PYG{c+c1}{// 创建一个填充0的大数组.}

\PYG{n}{QVector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}::}\PYG{n}{iterator}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{();}
\PYG{c+c1}{// 迭代器i的错误用法:}
\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{c+cm}{/*}
\PYG{c+cm}{    现在我们应当小心地使用迭代器`i`，因为 i 指向的是共享的数据。}
\PYG{c+cm}{    如果我们执行 *i = 4 那么我们可能改变共享的实例（两个数组共享）}
\PYG{c+cm}{    这个行为和 STL 容器是不同的。在 Qt 中不要这样做。}
\PYG{c+cm}{*/}

\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{c+cm}{/*}
\PYG{c+cm}{    容器 a 现在已经和共享数据脱离，}
\PYG{c+cm}{    即使 i 之前是容器 a 的迭代器，但现在它是作为 b 的迭代器而存在。}
\PYG{c+cm}{    此时 (*i) == 0}
\PYG{c+cm}{*/}

\PYG{n}{b}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{();}\PYG{+w}{ }\PYG{c+c1}{// 此时 i 彻底失效}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{i}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// 未定义行为!}
\PYG{c+cm}{/*}
\PYG{c+cm}{    b 中的数据（即i 指向的）已经被释放，}
\PYG{c+cm}{    在 STL 容器中这是有明确定义的（(*i) == 5），}
\PYG{c+cm}{    但对于 QVector 来说这样做很有可能导致崩溃。}
\PYG{c+cm}{*/}
\end{Verbatim}
