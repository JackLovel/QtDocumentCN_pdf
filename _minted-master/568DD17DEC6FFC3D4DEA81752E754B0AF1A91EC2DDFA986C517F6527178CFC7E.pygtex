\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{OtherClass}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{Ipublic}\PYG{o}{:}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{Iconst}\PYG{+w}{ }\PYG{n}{CopyClass}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{instance}\PYG{p}{()}\PYG{+w}{ }\PYG{k}{const}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// 此处会返回什么？我应该将返回值赋值给谁？}
\PYG{p}{\PYGZcb{};}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}
\PYG{err}{（}\PYG{n}{此小节正在施工中}\PYG{err}{）}

\PYG{err}{\PYGZbs{}}\PYG{n}{section}\PYG{p}{\PYGZob{}}\PYG{n}{不变性}\PYG{p}{\PYGZcb{}}

\PYG{n}{C}\PYG{o}{++}\PYG{+w}{ }\PYG{n}{提供了}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{关键字来标识不会改变或不会产生副作用的事物}\PYG{err}{。}\PYG{n}{它可被用于数值}\PYG{err}{、}\PYG{n}{指针和倍只想的内容}\PYG{err}{，}\PYG{n}{也可被作为成员函数的特殊属性来标识它不会修改对象的状态}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{notice}\PYG{p}{\PYGZcb{}}
\PYG{k}{const}\PYG{+w}{ }\PYG{n}{自身并不提供太大的价值}\PYG{err}{——}\PYG{n}{许多语言甚至并未提供}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{关键字}\PYG{err}{，}\PYG{n}{但这并不会自动导致它们存在缺陷}\PYG{err}{。}\PYG{n}{事实上}\PYG{err}{，}\PYG{n}{若移除所有函数重载}\PYG{err}{，}\PYG{n}{并通过搜索替换移除}\PYG{+w}{ }\PYG{n}{C}\PYG{o}{++}\PYG{+w}{ }\PYG{n}{代码中的所有}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{标识}\PYG{err}{，}\PYG{n}{代码很可能依然能够编译并正确执行}\PYG{err}{。}\PYG{n}{使用实用主义导向来使用}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{是很重要的}\PYG{err}{。}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{notice}\PYG{p}{\PYGZcb{}}

\PYG{n}{让我们看看}\PYG{+w}{ }\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{中使用}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{的}\PYG{+w}{ }\PYG{n}{API}\PYG{+w}{ }\PYG{n}{设计}\PYG{err}{：}

\PYG{n}{输入参数}\PYG{err}{：}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{指针}

\PYG{n}{使用指针输入参数的}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{成员函数几乎总是使用}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{指针}\PYG{err}{。}

\PYG{n}{若一个成员函数确实被声明为}\PYG{+w}{ }\PYG{k}{const}\PYG{err}{，}\PYG{n}{这意味着它不具有副作用}\PYG{err}{，}\PYG{n}{也不会修改对象对外可见的状态}\PYG{err}{。}\PYG{n}{那么}\PYG{err}{，}\PYG{n}{为什么要需要非}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{的输入参数}\PYG{err}{？}\PYG{n}{需要牢记}\PYG{err}{，}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{成员函数经常会被其它}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{成员函数}\PYG{err}{，}\PYG{n}{在这些调用场合中}\PYG{err}{，}\PYG{n}{非}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{的指针并不容易得到}\PYG{err}{（}\PYG{n}{除非使用}\PYG{+w}{ }\PYG{k}{const}\PYG{err}{\PYGZbs{}}\PYG{n}{\PYGZus{}cast}\PYG{err}{，}\PYG{n}{而我们应该尽可能避免使用它}\PYG{err}{）。}

\PYG{n}{修改之前}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}[}\PYG{n}{language}\PYG{o}{=}\PYG{n}{C}\PYG{o}{++}\PYG{p}{]}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{QWidget}\PYG{o}{::}\PYG{n}{isVisibleTo}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QWidget}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{ancestor}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{const}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{QWidget::isEnabledTo}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QWidget}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{ancestor}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{const}\PYG{p}{;}
\PYG{n}{QPoint}\PYG{+w}{ }\PYG{n+nf}{QWidget::mapFrom}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QWidget}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{ancestor}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QPoint}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{pos}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{const}\PYG{p}{;}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{notice}\PYG{p}{\PYGZcb{}}
\PYG{n}{我们在}\PYG{+w}{ }\PYG{n}{QGraphicsItem}\PYG{+w}{ }\PYG{n}{中修复了这些成员函数}\PYG{err}{，}\PYG{n}{但}\PYG{+w}{ }\PYG{n}{QWidget}\PYG{+w}{ }\PYG{n}{的修复需要等待}\PYG{+w}{ }\PYG{n}{Qt}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{err}{：}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{notice}\PYG{p}{\PYGZcb{}}


\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}[}\PYG{n}{language}\PYG{o}{=}\PYG{n}{C}\PYG{o}{++}\PYG{p}{]}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{isVisibleTo}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QGraphicsItem}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{parent}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{const}\PYG{p}{;}
\PYG{n}{QPointF}\PYG{+w}{ }\PYG{n+nf}{mapFromItem}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QGraphicsItem}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{item}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QPointF}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{point}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{const}\PYG{p}{;}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{返回值}\PYG{err}{：}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{值}

\PYG{n}{函数的返回值}\PYG{err}{，}\PYG{n}{要么是引用类型}\PYG{err}{，}\PYG{n}{要么是右值}\PYG{err}{。}

\PYG{n}{非类类型的右值是不受cv限定符影响的}\PYG{err}{。}\PYG{n}{因此}\PYG{err}{，}\PYG{n}{即使在语法上允许为其添加}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{修饰}\PYG{err}{，}\PYG{n}{这并不会产生效果}\PYG{err}{，}\PYG{n}{因为由于其访问权不允许对其做出修改}\PYG{err}{。}\PYG{n}{大多数现代编译器在编译此类代码时会打印警告信息}\PYG{err}{。}

\PYG{n}{当为类类型的右值添加}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{时}\PYG{err}{，}\PYG{n}{对该类的非}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{的成员函数的访问会被禁止}\PYG{err}{，}\PYG{n}{对其成员变量的直接操作也会被禁止}\PYG{err}{。}

\PYG{n}{不添加}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{允许此类操作}\PYG{err}{，}\PYG{n}{但很少有此类需求}\PYG{err}{，}\PYG{n}{因为这些修改会伴随右值对象生命周期的结束而消失}\PYG{err}{，}\PYG{n}{这会在当前语句的分号结束后发生}\PYG{err}{。}

\PYG{n}{例如}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}[}\PYG{n}{language}\PYG{o}{=}\PYG{n}{C}\PYG{o}{++}\PYG{p}{]}
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{Foo}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{Ivoid}\PYG{+w}{ }\PYG{n}{setValue}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{v}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{n}{value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{v}\PYG{p}{;}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{;}
\PYG{p}{\PYGZcb{};}

\PYG{n}{Foo}\PYG{+w}{ }\PYG{n+nf}{foo}\PYG{p}{()}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{Foo}\PYG{p}{();}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}
\PYG{k}{const}\PYG{+w}{ }\PYG{n}{Foo}\PYG{+w}{ }\PYG{n+nf}{cfoo}\PYG{p}{()}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{Foo}\PYG{p}{();}\PYG{+w}{ }\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{()}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{I}\PYG{c+c1}{// 下述代码可以编译，foo() 返回非 const 右值，无法}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{I}\PYG{c+c1}{// 成为赋值目标（这通常需要左值），但对成员变量的访问}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{I}\PYG{c+c1}{// 是左值：}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{Ifoo}\PYG{p}{().}\PYG{n}{value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// 可以编译，但该临时值在这个完整的表达式结束后会被抛弃}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{I}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{I}\PYG{c+c1}{// 下述代码可以编译，foo() 返回非 const 右值，无法}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{I}\PYG{c+c1}{// 成为赋值目标，但可以调用（甚至于非 const 的)成员函数：}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{Ifoo}\PYG{p}{().}\PYG{n}{setValue}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{);}\PYG{+w}{ }\PYG{c+c1}{// 可以编译，但该临时值在这个完整的表达式结束后会被抛弃}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{I}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{I}\PYG{c+c1}{// 下述代码无法编译，cfoo() 返回 const 右值，因此其}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{I}\PYG{c+c1}{// 成员变量是 const 授权，无法被赋值：}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{Icfoo}\PYG{p}{().}\PYG{n}{value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// 无法编译}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{I}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{I}\PYG{c+c1}{// 下述代码无法编译，cfoo() 返回 const 右值，无法调用}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{I}\PYG{c+c1}{// 其非 const 的成员函数：}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{Icfoo}\PYG{p}{().}\PYG{n}{setValue}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{);}\PYG{+w}{ }\PYG{c+c1}{// 无法编译}
\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{返回值}\PYG{err}{：}\PYG{n}{指针与}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{指针}

\PYG{k}{const}\PYG{+w}{ }\PYG{n}{成员函数应该返回指针还是}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{指针这个问题}\PYG{err}{，}\PYG{n}{令许多人发现}\PYG{+w}{ }\PYG{n}{C}\PYG{o}{++}\PYG{+w}{ }\PYG{n}{的}\PYG{err}{“}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{正确性}\PYG{err}{”}\PYG{n}{被瓦解了}\PYG{err}{。}\PYG{n}{该问题源于某些}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{成员函数}\PYG{err}{，}\PYG{n}{并不修改它们的内部状态}\PYG{err}{，}\PYG{n}{而是返回成员变量的非}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{指针}\PYG{err}{。}\PYG{n}{单纯返回一个指针并不会影响对象对外可见的状态}\PYG{err}{，}\PYG{n}{也不会修改它正在维护的状态}\PYG{err}{。}\PYG{n}{但这会令程序员获得间接地修改对象数据的权限}\PYG{err}{。}

\PYG{n}{下述范例展示了通过}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{成员函数返回的非}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{指针来规避不可变性的诸多方法之一}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}[}\PYG{n}{language}\PYG{o}{=}\PYG{n}{C}\PYG{o}{++}\PYG{p}{]}
\PYG{n}{QVariant}\PYG{+w}{ }\PYG{n}{CustomWidget}\PYG{o}{::}\PYG{n}{inputMethodQuery}\PYG{p}{(}\PYG{n}{Qt}\PYG{o}{::}\PYG{n}{InputMethodQuery}\PYG{+w}{ }\PYG{n}{query}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{ImoveBy}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{);}\PYG{+w}{ }\PYG{c+c1}{// 无法编译！}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{Iwindow}\PYG{p}{()}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{childAt}\PYG{p}{(}\PYG{n}{mapTo}\PYG{p}{(}\PYG{n}{window}\PYG{p}{(),}\PYG{+w}{ }\PYG{n}{rect}\PYG{p}{().}\PYG{n}{center}\PYG{p}{()))}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{moveBy}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{);}\PYG{+w}{ }\PYG{c+c1}{// 可以编译！}
\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{返回}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{指针的函数}\PYG{err}{，}\PYG{n}{至少在一定程度上}\PYG{err}{，}\PYG{n}{避免了此类}\PYG{err}{（}\PYG{n}{可能并不希望}\PYG{o}{/}\PYG{n}{非预期的}\PYG{err}{）}\PYG{n}{副作用}\PYG{err}{。}\PYG{n}{但哪些函数会考虑返回}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{指针}\PYG{err}{，}\PYG{n}{或一组}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{指针}\PYG{err}{？}\PYG{n}{若我们使用}\PYG{+w}{ }\PYG{n}{const正确}\PYG{+w}{ }\PYG{n}{的方案}\PYG{err}{，}\PYG{n}{即令任何}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{成员函数返回成员变量}\PYG{err}{（}\PYG{n}{或一组成员变量的指针}\PYG{err}{）}\PYG{n}{时都是用}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{指针形式}\PYG{err}{。}\PYG{n}{很不幸的是}\PYG{err}{，}\PYG{n}{实际中这会造就无法使用的}\PYG{+w}{ }\PYG{n}{API}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}[}\PYG{n}{language}\PYG{o}{=}\PYG{n}{C}\PYG{o}{++}\PYG{p}{]}
\PYG{n}{QGraphicsScene}\PYG{+w}{ }\PYG{n}{scene}\PYG{p}{;}
\PYG{c+c1}{// … 初始化场景}
\PYG{n}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QGraphicsItem}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{item}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{scene}\PYG{p}{.}\PYG{n}{items}\PYG{p}{())}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{o}{\PYGZca{}\PYGZca{}}\PYG{n}{Iitem}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{setPos}\PYG{p}{(}\PYG{n}{qrand}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{500}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{qrand}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{500}\PYG{p}{);}\PYG{+w}{ }\PYG{c+c1}{// 无法编译！item 是 const 指针}
\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{QGraphicsScene}\PYG{o}{::}\PYG{n}{items}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{是}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{成员函数}\PYG{err}{，}\PYG{n}{这可能会让人觉得应该返回}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{指针}\PYG{err}{。}

\PYG{n}{在}\PYG{+w}{ }\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{中}\PYG{err}{，}\PYG{n}{我们近乎只使用非}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{的模式}\PYG{err}{。}\PYG{n}{我们选择了实用主义之路}\PYG{err}{：}\PYG{n}{返回}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{指针更容易导致}\PYG{+w}{ }\PYG{k}{const}\PYG{err}{\PYGZbs{}}\PYG{n}{\PYGZus{}cast}\PYG{+w}{ }\PYG{n}{的过度使用}\PYG{err}{，}\PYG{n}{这比滥用返回的非}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{指针引发的问题更加频繁}\PYG{err}{。}

\PYG{n}{返回类型}\PYG{err}{：}\PYG{n}{值}\PYG{+w}{ }\PYG{n}{或}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{引用}\PYG{err}{？}

\PYG{n}{如果我们在返回对象时还保留了它的副本}\PYG{err}{，}\PYG{n}{返回}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{引用是最快的方法}\PYG{err}{；}\PYG{n}{然而}\PYG{err}{，}\PYG{n}{这在我们之后打算重构这个类时成为了限制}\PYG{err}{（}\PYG{n}{使用}\PYG{+w}{ }\PYG{n}{d}\PYG{+w}{ }\PYG{n}{指针惯用法}\PYG{err}{，}\PYG{n}{我们可以在任何时候修改}\PYG{+w}{ }\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{类的内存结构}\PYG{err}{；}\PYG{n}{但我们无法在不破坏二进制兼容性的前提下}\PYG{err}{，}\PYG{n}{将函数签名从}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QFoo}\PYG{err}{\PYGZbs{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{改为}\PYG{+w}{ }\PYG{n}{QFoo}\PYG{err}{）。}\PYG{n}{出于此原因}\PYG{err}{，}\PYG{n}{我们通常返回}\PYG{+w}{ }\PYG{n}{QFoo}\PYG{+w}{ }\PYG{n}{而非}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QFoo}\PYG{err}{\PYGZbs{}}\PYG{o}{\PYGZam{}}\PYG{err}{，}\PYG{n}{除了性能极端敏感}\PYG{err}{，}\PYG{n}{而重构并不是问题的少数场合}\PYG{err}{（}\PYG{n}{例如}\PYG{+w}{ }\PYG{n}{QList}\PYG{o}{::}\PYG{n}{at}\PYG{p}{()}\PYG{err}{）。}

\PYG{k}{const}\PYG{+w}{ }\PYG{n}{与}\PYG{+w}{ }\PYG{n}{对象的状态}

\PYG{n}{const正确性}\PYG{+w}{ }\PYG{n}{是}\PYG{+w}{ }\PYG{n}{C}\PYG{+w}{ }\PYG{n}{中的一场}\PYG{err}{“}\PYG{n}{圣战}\PYG{err}{”（}\PYG{n}{译者注}\PYG{err}{：}\PYG{n}{原文为}\PYG{+w}{ }\PYG{n}{vi}\PYG{o}{\PYGZhy{}}\PYG{n}{emacs}\PYG{+w}{ }\PYG{n}{discussion}\PYG{err}{），}\PYG{n}{因为该原则在一些领域}\PYG{err}{（}\PYG{n}{如基于指针的函数}\PYG{err}{）}\PYG{n}{中是失效了}\PYG{err}{。}

\PYG{n}{但}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{成员函数的常规含义是值不会修改一个类对外可见的状态}\PYG{err}{，}\PYG{n}{状态在此处值}\PYG{err}{“}\PYG{n}{我自己的和我负责的}\PYG{err}{”。}\PYG{n}{这并不意味着}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{成员函数会改变它们自己的私有成员变量}\PYG{err}{，}\PYG{n}{但也不代表不能这么做}\PYG{err}{。}\PYG{n}{但通常来说}\PYG{err}{，}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{成员函数不会产生可见的副作用}\PYG{err}{。}\PYG{n}{例如}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}[}\PYG{n}{language}\PYG{o}{=}\PYG{n}{C}\PYG{o}{++}\PYG{p}{]}
\PYG{n}{QSize}\PYG{+w}{ }\PYG{n}{size}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{widget}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{sizeHint}\PYG{p}{();}\PYG{+w}{ }\PYG{c+c1}{// const}
\PYG{n}{widget}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{move}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{);}\PYG{+w}{ }\PYG{c+c1}{// 非 const}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{代理对象负责处理对另一个对象的绘制工作}\PYG{err}{，}\PYG{n}{它的状态包含了它负责的内容}\PYG{err}{，}\PYG{n}{也就是包含它的绘制目标的状态}\PYG{err}{。}\PYG{n}{请求代理进行绘制是具有副作用的}\PYG{err}{：}\PYG{n}{这会改变正在被绘制的设备的外观}\PYG{err}{（}\PYG{n}{也意味着状态}\PYG{err}{）。}\PYG{n}{正因如此}\PYG{err}{，}\PYG{n}{令}\PYG{+w}{ }\PYG{n}{paint}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{成为}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{并不合理}\PYG{err}{。}\PYG{n}{任何视图控件或}\PYG{+w}{ }\PYG{n}{QIcon}\PYG{+w}{ }\PYG{n}{的}\PYG{+w}{ }\PYG{n}{paint}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{作为}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{都很不合理}\PYG{err}{。}\PYG{n}{没人会在}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{成员函数中去调用}\PYG{+w}{ }\PYG{n}{QIcon}\PYG{o}{::}\PYG{n}{paint}\PYG{p}{()}\PYG{err}{，}\PYG{n}{除非他们明确地像规避当前函数的}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{性质}\PYG{err}{。}\PYG{n}{而在这种场景中}\PYG{err}{，}\PYG{n}{显示的}\PYG{+w}{ }\PYG{k}{const}\PYG{err}{\PYGZbs{}}\PYG{n}{\PYGZus{}cast}\PYG{+w}{ }\PYG{n}{会是更好的选择}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}[}\PYG{n}{language}\PYG{o}{=}\PYG{n}{C}\PYG{o}{++}\PYG{p}{]}
\PYG{c+c1}{// QAbstractItemDelegate::paint 是 const}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{QAbstractItemDelegate}\PYG{o}{::}\PYG{n}{paint}\PYG{p}{(}\PYG{n}{QPainter}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{painter}\PYG{p}{,}
\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QStyleOptionViewItem}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{option}\PYG{p}{,}
\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QModelIndex}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{index}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{const}

\PYG{c+c1}{// QGraphicsItem::paint 不是 const}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{QGraphicsItem}\PYG{o}{::}\PYG{n}{paint}\PYG{p}{(}\PYG{n}{QPainter}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{painter}\PYG{p}{,}
\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QStyleOptionGraphicsItem}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{option}\PYG{p}{,}
\PYG{n}{QWidget}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{widget}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{k}{const}\PYG{+w}{ }\PYG{n}{关键字不会为你做任何事}\PYG{err}{，}\PYG{n}{考虑将其移除}\PYG{err}{，}\PYG{n}{而非为一个成员函数提供}\PYG{+w}{ }\PYG{k}{const}\PYG{o}{/}\PYG{n}{非}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{的重载版本}\PYG{err}{。}

\end{Verbatim}
