\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{QVector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{vector}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{};}
\PYG{n}{QSet}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{set}\PYG{p}{(}\PYG{n}{vector}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(),}\PYG{+w}{ }\PYG{n}{vector}\PYG{p}{.}\PYG{n}{end}\PYG{p}{());}
\PYG{c+cm}{/*}
\PYG{c+cm}{    将会生成一个 QSet，包含元素 1, 2, 4, 5。}
\PYG{c+cm}{*/}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{err}{\PYGZbs{}}\PYG{n}{section}\PYG{p}{\PYGZob{}}\PYG{n}{容器类}\PYG{p}{\PYGZcb{}}

\PYG{err}{\PYGZbs{}}\PYG{n}{splitLine}

\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{提供了以下几种顺序容器}\PYG{err}{：}\PYG{n}{QList}\PYG{err}{，}\PYG{n}{QLinkedList}\PYG{err}{，}\PYG{n}{QVector}\PYG{err}{，}\PYG{n}{QStack}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QQueue}\PYG{err}{。}\PYG{n}{对于大多数的应用}\PYG{err}{，}\PYG{n}{QList}\PYG{+w}{ }\PYG{n}{是最适用的}\PYG{err}{。}\PYG{n}{虽然其基于数组实现}\PYG{err}{，}\PYG{n}{但支持在头部和尾部快速插入}\PYG{err}{。}\PYG{n}{如果确实需要一个基于链表的列表}\PYG{err}{，}\PYG{n}{你可以使用}\PYG{+w}{ }\PYG{n}{QLinkedList}\PYG{err}{；}\PYG{n}{如果要求元素以连续内存的形式保存}\PYG{err}{，}\PYG{n}{那么可以使用}\PYG{+w}{ }\PYG{n}{QVector}\PYG{err}{。}\PYG{n}{QStack}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QQueue提供了}\PYG{+w}{ }\PYG{n}{LIFO}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{FIFO}\PYG{+w}{ }\PYG{n}{语义的支持}\PYG{err}{。}

\PYG{n}{Qt也提供了一系列关联容器}\PYG{err}{：}\PYG{n}{QMap}\PYG{err}{，}\PYG{n}{QMultiMap}\PYG{err}{，}\PYG{n}{QHash}\PYG{err}{，}\PYG{n}{QMultiHash}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QSet}\PYG{err}{。}\PYG{l+s}{\PYGZdq{}Multi\PYGZdq{}}\PYG{+w}{ }\PYG{n}{容器可以方便地支持键值一对多的情形}\PYG{err}{。“}\PYG{n}{Hash}\PYG{err}{”}\PYG{+w}{ }\PYG{n}{容器提供了快速查找的能力}\PYG{err}{，}\PYG{n}{这是通过使用哈希函数代替对有序集合进行二分查找实现的}\PYG{err}{。}

\PYG{n}{较为特殊的是}\PYG{+w}{ }\PYG{n}{QCache}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QContiguousCache}\PYG{err}{，}\PYG{n}{这两个类提供了在有限的缓存中}
\PYG{n}{快速查找元素的能力}\PYG{err}{。}


\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{tabular}\PYG{p}{\PYGZcb{}\PYGZob{}}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{类}\PYG{o}{\PYGZam{}}\PYG{n}{综述}\PYG{+w}{ }\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QList}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{这是目前使用最普遍的容器类}\PYG{err}{，}\PYG{n}{其保存了一个元素类型为T的列表}\PYG{err}{，}\PYG{n}{支持通过索引访问}\PYG{err}{。}\PYG{n}{QList}\PYG{+w}{ }\PYG{n}{内部通过数组实现}\PYG{err}{，}\PYG{n}{以确保基于索引的访问足够快}\PYG{err}{。}
\PYG{n}{元素可以通过}\PYG{+w}{ }\PYG{n}{QList}\PYG{o}{::}\PYG{n}{append}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QList}\PYG{o}{::}\PYG{n}{prepend}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{插入到首尾}\PYG{err}{，}\PYG{n}{也可以通过}\PYG{+w}{ }\PYG{n}{QList}\PYG{o}{::}\PYG{n}{insert}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{插入到列表中间}\PYG{err}{，}\PYG{n}{和其他容器类不同的是}\PYG{err}{，}\PYG{n}{QList}\PYG{+w}{ }\PYG{n}{为生成尽可能少的代码做了高度优化}\PYG{err}{。}\PYG{n}{QStringList}\PYG{+w}{ }\PYG{n}{继承于}\PYG{+w}{ }\PYG{n}{QList}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{err}{。}
\PYG{n}{QLinkedList}\PYG{p}{)}\PYG{+w}{	}\PYG{n}{这个类和}\PYG{+w}{ }\PYG{n}{QList}\PYG{+w}{ }\PYG{n}{很像}\PYG{err}{，}\PYG{n}{不同的是这个类使用迭代器进行而不是整形索引对元素进行访问}\PYG{err}{。}\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QList}\PYG{+w}{ }\PYG{n}{相比}\PYG{err}{，}\PYG{n}{其在中间插入大型列表时其性能更优}\PYG{err}{，}\PYG{n}{而且其具有更好的迭代器语义}\PYG{err}{。（}\PYG{n}{在}\PYG{+w}{ }\PYG{n}{QLinkedList}\PYG{+w}{ }\PYG{n}{中}\PYG{err}{，}\PYG{n}{指向一个元素的迭代器只要该元素存在}\PYG{err}{，}\PYG{n}{则会一直保持有效}\PYG{err}{，}\PYG{n}{而在}\PYG{+w}{ }\PYG{n}{QList}\PYG{+w}{ }\PYG{n}{的迭代器则可能会在任意的元素插入或删除后失效}\PYG{err}{。）}
\PYG{n}{QVector}\PYG{+w}{	}\PYG{n}{这个类以数组的形式保存给定类型的元素}\PYG{err}{，}\PYG{n}{在内存中元素彼此相邻}\PYG{err}{。}\PYG{n}{在}
\PYG{+w}{       }\PYG{n}{一个}\PYG{+w}{ }\PYG{n}{vector}\PYG{+w}{ }\PYG{n}{的头部或中部插入可能会相当慢}\PYG{err}{，}\PYG{n}{因为这可能会导致大量}
\PYG{+w}{       }\PYG{n}{元素需要在内存中移动一个位置}\PYG{err}{。\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QVarLengthArray}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Prealloc}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{+w}{	}\PYG{n}{这个类提供了一个底层的变长数组}\PYG{err}{，}\PYG{n}{在速度极其重要的情况下可以用来代替}\PYG{+w}{ }\PYG{n}{QVector}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{n}{QStack}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{这个类继承于}\PYG{+w}{ }\PYG{n}{QVector}\PYG{err}{，}\PYG{n}{用于为}\PYG{err}{”}\PYG{n}{后进}\PYG{err}{，}\PYG{n}{先出}\PYG{err}{”（}\PYG{n}{LIFO}\PYG{+w}{ }\PYG{err}{）}\PYG{n}{提供便捷的语}
\PYG{+w}{        }\PYG{n}{义支持}\PYG{err}{。}\PYG{n}{其为}\PYG{+w}{ }\PYG{n}{QVector}\PYG{+w}{ }\PYG{n}{添加了以下方法}\PYG{err}{：}\PYG{n}{QVector}\PYG{o}{::}\PYG{n}{push}\PYG{p}{()}\PYG{err}{，}\PYG{n}{pop}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{和}
\PYG{+w}{        }\PYG{n}{top}\PYG{p}{()}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QQueue}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{这个类继承于}\PYG{+w}{ }\PYG{n}{QVector}\PYG{err}{，}\PYG{n}{用于为}\PYG{err}{”}\PYG{n}{先进}\PYG{err}{，}\PYG{n}{先出}\PYG{err}{”（}\PYG{n}{FIFO}\PYG{+w}{ }\PYG{err}{）}\PYG{n}{提供便捷的语}
\PYG{+w}{        }\PYG{n}{义支持}\PYG{err}{。}\PYG{n}{其为}\PYG{+w}{ }\PYG{n}{QVector}\PYG{+w}{ }\PYG{n}{添加了以下方法}\PYG{err}{：}\PYG{n}{QList}\PYG{o}{::}\PYG{n}{enqueue}\PYG{p}{()}\PYG{err}{，}
\PYG{+w}{        }\PYG{n}{dequeue}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{()}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QSet}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{这个类提供了一个单值数学集合}\PYG{err}{，}\PYG{n}{支持快速查找}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QMap}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{+w}{	}\PYG{n}{这个类提供了一个将类型为Key的键映射到类型为T的值的字典}\PYG{err}{（}\PYG{n}{关联数组}\PYG{err}{）。}\PYG{n}{通常情况下键值是一一对应的}\PYG{err}{。}\PYG{n}{QMap}\PYG{+w}{ }\PYG{n}{根据Key进行排序}\PYG{err}{，}\PYG{n}{如果排序无关紧要}\PYG{err}{，}\PYG{n}{使用}\PYG{+w}{ }\PYG{n}{QHash}\PYG{+w}{ }\PYG{n}{代替速度会更快}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QMultiMap}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{+w}{	}\PYG{n}{这个类继承于}\PYG{+w}{ }\PYG{n}{QMap}\PYG{err}{，}\PYG{n}{其为诸如键值一对多的多值映射提供了一个友好的接口}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QHash}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{+w}{	}\PYG{n}{这个类几乎与}\PYG{+w}{ }\PYG{n}{QMap}\PYG{+w}{ }\PYG{n}{有完全一致的}\PYG{+w}{ }\PYG{n}{API}\PYG{+w}{ }\PYG{err}{，}\PYG{n}{但查找效率会有明}
\PYG{+w}{               }\PYG{n}{显的提高}\PYG{err}{。}\PYG{n}{QHash}\PYG{+w}{ }\PYG{n}{的数据是无序的}\PYG{err}{。\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QMultiHash}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{这个类继承于}\PYG{+w}{ }\PYG{n}{QMap}\PYG{err}{，}\PYG{n}{其为多值映射提供了一个友好的接口}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{tabular}\PYG{p}{\PYGZcb{}}

\PYG{n}{容器可以嵌套}\PYG{err}{。}\PYG{n}{例如在键为}\PYG{+w}{ }\PYG{n}{QString}\PYG{err}{，}\PYG{n}{值为}\PYG{+w}{ }\PYG{n}{QList}\PYG{+w}{ }\PYG{n}{时}\PYG{err}{，}\PYG{n}{完全可以使用}\PYG{+w}{ }\PYG{n}{QMap}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QList}\PYG{o}{\PYGZgt{}}\PYG{err}{。}

\PYG{n}{容器类的定义位于和容器同名的独立头文件中}\PYG{err}{（}\PYG{n}{例如}\PYG{err}{，}\PYG{o}{\PYGZlt{}}\PYG{n}{QLinkedList}\PYG{o}{\PYGZgt{}}\PYG{err}{）。}\PYG{n}{为了方便}\PYG{err}{，}\PYG{n}{在}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{n}{QtContainerFwd}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{中对所有容器类进行了前置声明}\PYG{err}{。}

\PYG{n}{保存在各个容器中的值类型可以是任意可复制数据类型}\PYG{err}{。}\PYG{n}{为了满足这一要求}\PYG{err}{，}\PYG{n}{该类型必须提供一个复制构造函数和一个赋值运算符}\PYG{err}{。}\PYG{n}{某些操作可能还要求类型支持默认构造函数}\PYG{err}{。}\PYG{n}{对于大多数你想要在容器中保存的类型都满足这些要求}\PYG{err}{，}\PYG{n}{包括基本类型}\PYG{err}{，}\PYG{n}{如}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{err}{，}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{err}{，}\PYG{n}{指针类型}\PYG{err}{，}\PYG{n}{以及}\PYG{+w}{ }\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{数据类型}\PYG{err}{，}\PYG{n}{如}\PYG{+w}{ }\PYG{n}{QString}\PYG{err}{，}\PYG{n}{QDate}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QTime}\PYG{err}{，}\PYG{n}{但并不包括}\PYG{+w}{ }\PYG{n}{QObject}\PYG{+w}{ }\PYG{n}{及其子类}\PYG{err}{（}\PYG{n}{QWidget}\PYG{err}{，}\PYG{n}{QDialog}\PYG{err}{，}\PYG{n}{QTimer}\PYG{+w}{ }\PYG{n}{等}\PYG{err}{）。}\PYG{n}{如果你尝试实例化一个}\PYG{+w}{ }\PYG{n}{QList}\PYG{o}{\PYGZlt{}}\PYG{n}{QWidget}\PYG{o}{\PYGZgt{}}\PYG{err}{，}\PYG{n}{编译器将会抱怨道}\PYG{+w}{ }\PYG{n}{QWidget}\PYG{+w}{ }\PYG{n}{的复制构造函数和赋值运算符被禁用了}\PYG{err}{。}\PYG{n}{如果需要在容器中保存这些类型的元素}\PYG{err}{，}\PYG{n}{可以保存其指针}\PYG{err}{，}\PYG{n}{如}\PYG{+w}{ }\PYG{n}{QList}\PYG{o}{\PYGZlt{}}\PYG{n}{QWidget}\PYG{+w}{ }\PYG{o}{*\PYGZgt{}}\PYG{err}{。}

\PYG{n}{下面是一个满足可赋值数据类型要求的自定义数据类型的例子}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{Employee}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{    }\PYG{n}{Employee}\PYG{p}{()}\PYG{+w}{ }\PYG{p}{\PYGZob{}\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{Employee}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{Employee}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{other}\PYG{p}{);}

\PYG{+w}{    }\PYG{n}{Employee}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{=}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{Employee}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{other}\PYG{p}{);}

\PYG{k}{private}\PYG{o}{:}
\PYG{+w}{    }\PYG{n}{QString}\PYG{+w}{ }\PYG{n}{myName}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{QDate}\PYG{+w}{ }\PYG{n}{myDateOfBirth}\PYG{p}{;}
\PYG{p}{\PYGZcb{};}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{如果我们没有提供一个复制构造函数或一个赋值运算符}\PYG{err}{，}\PYG{n}{C}\PYG{o}{++}\PYG{+w}{ }\PYG{n}{将会提供一个表现}
\PYG{n}{为逐个复制成员的默认实现}\PYG{err}{。}\PYG{n}{在上面的例子中}\PYG{err}{，}\PYG{n}{默认行为就足够了}\PYG{err}{。}\PYG{n}{同样的}\PYG{err}{，}\PYG{n}{如}
\PYG{n}{果没有提供默认构造函数}\PYG{err}{，}\PYG{n}{C}\PYG{o}{++}\PYG{+w}{ }\PYG{n}{会提供一个默认构造函数}\PYG{err}{，}\PYG{n}{对成员进行默认构造}\PYG{err}{。}
\PYG{n}{尽管没有提供任何的构造函数或赋值运算符}\PYG{err}{，}\PYG{n}{下面的数据类型可以被保存于容器}
\PYG{n}{中}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{Movie}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{id}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{QString}\PYG{+w}{ }\PYG{n}{title}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{QDate}\PYG{+w}{ }\PYG{n}{releaseDate}\PYG{p}{;}
\PYG{p}{\PYGZcb{};}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{一些容器对它们所能保存的数据类型有额外的要求}\PYG{err}{。}\PYG{n}{举个例子}\PYG{err}{，}\PYG{n}{QMap}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{的键类型}\PYG{+w}{ }\PYG{n}{Key}\PYG{+w}{ }\PYG{n}{必须提供}\PYG{+w}{ }\PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{方法}\PYG{err}{。}\PYG{n}{这些特殊要求在类的详细描述中有说明}\PYG{err}{。}\PYG{n}{在某些情况下}\PYG{err}{，}\PYG{n}{特定函数会有特定的要求}\PYG{err}{，}\PYG{n}{这在函数的描述中有说明}\PYG{err}{。}\PYG{n}{如果条件不满足}\PYG{err}{，}\PYG{n}{编译器将总是会报错}\PYG{err}{。}

\PYG{n}{Qt容器提供了}\PYG{+w}{ }\PYG{k}{operator}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{k}{operator}\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{p}{()}\PYG{err}{，}\PYG{n}{因此这些类可以很方便地通过}
\PYG{n}{QDataStream}\PYG{+w}{ }\PYG{n}{进行读写}\PYG{err}{。}\PYG{n}{这意味着存储在容器中的元素类型也必须支持}
\PYG{k}{operator}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{k}{operator}\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{p}{()}\PYG{err}{。}\PYG{n}{支持这一点是很简单的}\PYG{err}{；}\PYG{n}{以下是我们使上面的}
\PYG{n}{Movie}\PYG{+w}{ }\PYG{n}{结构体支持这一点所做的改动}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QDataStream}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{p}{(}\PYG{n}{QDataStream}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{out}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{Movie}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{movie}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{out}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{quint32}\PYG{p}{)}\PYG{n}{movie}\PYG{p}{.}\PYG{n}{id}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{n}{movie}\PYG{p}{.}\PYG{n}{title}
\PYG{+w}{        }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{n}{movie}\PYG{p}{.}\PYG{n}{releaseDate}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{out}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{QDataStream}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{k}{operator}\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{p}{(}\PYG{n}{QDataStream}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{in}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Movie}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{movie}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{quint32}\PYG{+w}{ }\PYG{n}{id}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{QDate}\PYG{+w}{ }\PYG{n}{date}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{in}\PYG{+w}{ }\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{+w}{ }\PYG{n}{id}\PYG{+w}{ }\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{+w}{ }\PYG{n}{movie}\PYG{p}{.}\PYG{n}{title}\PYG{+w}{ }\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{+w}{ }\PYG{n}{date}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{movie}\PYG{p}{.}\PYG{n}{id}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{n}{id}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{movie}\PYG{p}{.}\PYG{n}{releaseDate}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{date}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{in}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{某些容器类的文档中会提到默认值}\PYG{err}{；}\PYG{n}{举个例子}\PYG{err}{，}\PYG{n}{QVector}\PYG{+w}{ }\PYG{n}{会自动使用默认值初始化其元素}\PYG{err}{；}\PYG{n}{QMap}\PYG{o}{::}\PYG{n}{value}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{在指定键不存在时会返回一个默认值}\PYG{err}{。}\PYG{n}{对于大部分的值类型}\PYG{err}{，}\PYG{n}{这就是简单地代表通过默认构造函数创建的值}\PYG{err}{（}\PYG{n}{例如对于}\PYG{+w}{ }\PYG{n}{QString}\PYG{+w}{ }\PYG{n}{即空字符串}\PYG{err}{）。}\PYG{n}{但是对于基本类型}\PYG{err}{，}\PYG{n}{如}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{和指针类型}\PYG{err}{，}\PYG{n}{C}\PYG{o}{++}\PYG{+w}{ }\PYG{n}{语言并没有规定任何的初始化方式}\PYG{err}{，}\PYG{n}{因此在这些情况下}\PYG{err}{，}\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{容器将会自动将其初始化为0}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{splitLine}

\PYG{err}{\PYGZbs{}}\PYG{n}{section}\PYG{p}{\PYGZob{}}\PYG{n}{迭代器类}\PYG{p}{\PYGZcb{}}

\PYG{n}{迭代器提供了一个统一的方式去访问容器中的元素}\PYG{err}{。}\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{容器类提供了两种风格迭代器}\PYG{err}{：}\PYG{n}{Java}\PYG{+w}{ }\PYG{n}{风格迭代器和}\PYG{+w}{ }\PYG{n}{STL}\PYG{+w}{ }\PYG{n}{风格迭代器}\PYG{err}{。}\PYG{n}{两种迭代器均会在容器中的数据被修改或因调用非}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{成员函数导致数据从隐式共享中分离后失效}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{splitLine}

\PYG{err}{\PYGZbs{}}\PYG{n}{subsection}\PYG{p}{\PYGZob{}}\PYG{n}{Java}\PYG{+w}{ }\PYG{n}{风格迭代器}\PYG{p}{\PYGZcb{}}

\PYG{n}{Java}\PYG{+w}{ }\PYG{n}{风格迭代器在}\PYG{+w}{ }\PYG{n}{Qt4}\PYG{+w}{ }\PYG{n}{中引入}\PYG{err}{，}\PYG{n}{作为标准使用在Qt应用中}\PYG{err}{。}\PYG{n}{和}\PYG{+w}{ }\PYG{n}{STL}\PYG{+w}{ }\PYG{n}{风格迭代器相比}\PYG{err}{，}\PYG{n}{其易用性更高}\PYG{err}{，}\PYG{n}{代价是性能略低}\PYG{err}{。}\PYG{n}{该风格迭代器}\PYG{+w}{ }\PYG{n}{API}\PYG{+w}{ }\PYG{n}{以}\PYG{+w}{ }\PYG{n}{Java}\PYG{+w}{ }\PYG{n}{迭代器类为原型设计}\PYG{err}{。}

\PYG{n}{对于每一个容器类}\PYG{err}{，}\PYG{n}{同时提供了两种数据类型的}\PYG{+w}{ }\PYG{n}{Java}\PYG{+w}{ }\PYG{n}{风格迭代器}\PYG{err}{：}\PYG{n}{一种支持只}
\PYG{n}{读访问}\PYG{err}{，}\PYG{n}{另一种支持读写访问}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{tabular}\PYG{p}{\PYGZcb{}\PYGZob{}}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{容器}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{只读迭代器}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{读写迭代器}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QList}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QQueue}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{QListIterator}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{QMutableListIterator}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QLinkedList}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{QLinkedListIterator}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{QMutableLinkedListIterator}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QVector}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QStack}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{QVectorIterator}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{QMutableVectorIterator}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QSet}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{QSetIterator}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{QMutableSetIterator}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QMap}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QMultiMap}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{QMapIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}\PYGZam{}}
\PYG{+w}{                                                       }\PYG{n}{QMutableMapIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}
\PYG{+w}{                                                       }\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QHash}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QMultiHash}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{+w}{	}\PYG{n}{QHashIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{+w}{	}\PYG{n}{QMutableHashIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{tabular}\PYG{p}{\PYGZcb{}}

\PYG{n}{在接下来的讨论中}\PYG{err}{，}\PYG{n}{我们将重点关注}\PYG{+w}{ }\PYG{n}{QList}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QMap}\PYG{err}{。}\PYG{n}{QLinkedList}\PYG{err}{，}\PYG{n}{QVector}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QSet}\PYG{+w}{ }\PYG{n}{的迭代器类型和}\PYG{+w}{ }\PYG{n}{QList}\PYG{+w}{ }\PYG{n}{有完全一样的接口}\PYG{err}{，}\PYG{n}{类似的}\PYG{err}{，}\PYG{n}{QHash}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QMap}\PYG{+w}{ }\PYG{n}{的迭代器类型的接口也是相同的}\PYG{err}{。}

\PYG{n}{和}\PYG{+w}{ }\PYG{n}{STL}\PYG{+w}{ }\PYG{n}{风格迭代器}\PYG{err}{（}\PYG{n}{下一节介绍}\PYG{err}{）}\PYG{n}{不同}\PYG{err}{，}\PYG{n}{Java}\PYG{+w}{ }\PYG{n}{风格迭代器指向的是元素间隙而}
\PYG{n}{不是元素本身}\PYG{err}{。}\PYG{n}{因此}\PYG{err}{，}\PYG{n}{Java}\PYG{+w}{ }\PYG{n}{风格迭代器可以指向容器最前}\PYG{err}{（}\PYG{n}{在第一个元素之前}\PYG{err}{），}
\PYG{n}{也可以指向容器最后}\PYG{err}{（}\PYG{n}{在最后一个元素之后}\PYG{err}{），}\PYG{n}{还可以指向两个元素之间}\PYG{err}{。}\PYG{n}{下图}
\PYG{n}{用红色箭头展示了一个四个元素的列表容器合法的迭代器位置}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{figure}\PYG{p}{\PYGZcb{}[}\PYG{n}{hbt}\PYG{o}{!}\PYG{p}{]}
\PYG{+w}{	}\PYG{err}{\PYGZbs{}}\PYG{n}{centering}
\PYG{+w}{    }\PYG{err}{\PYGZbs{}}\PYG{n}{includegraphics}\PYG{p}{[}\PYG{n}{width}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{err}{\PYGZbs{}}\PYG{n}{textwidth}\PYG{p}{]\PYGZob{}}\PYG{n}{java\PYGZus{}style\PYGZus{}iterator}\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{figure}\PYG{p}{\PYGZcb{}}

\PYG{n}{这是一个通过循环迭代有序遍历}\PYG{+w}{ }\PYG{n}{QList}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{中的所有元素并打印到终端的}
\PYG{n}{常用写法}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QList}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{;}
\PYG{n}{list}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}A\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}B\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}C\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}D\PYGZdq{}}\PYG{p}{;}

\PYG{n}{QListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{(}\PYG{n}{list}\PYG{p}{);}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{hasNext}\PYG{p}{())}
\PYG{+w}{    }\PYG{n}{qDebug}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{.}\PYG{n}{next}\PYG{p}{();}

\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{它的工作原理如下}\PYG{err}{：}\PYG{n}{需要被迭代的}\PYG{+w}{ }\PYG{n}{QList}\PYG{+w}{ }\PYG{n}{对象作为参数传递给}\PYG{+w}{ }\PYG{n}{QListIterator}\PYG{+w}{ }\PYG{n}{的构造函数}\PYG{err}{。}\PYG{n}{此时迭代器位于列表中第一个元素的前面}\PYG{err}{（}\PYG{n}{位于元素}\PYG{err}{“}\PYG{n}{A}\PYG{err}{“}\PYG{n}{之前}\PYG{err}{）。}\PYG{n}{接着我们调用}\PYG{+w}{ }\PYG{n}{hasNext}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{检查迭代器之后是否有元素}\PYG{err}{，}\PYG{n}{如果有}\PYG{err}{，}\PYG{n}{我们调用}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{跳过这个元素}\PYG{err}{。}\PYG{n}{next}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{方法会返回其跳过的元素}\PYG{err}{。}\PYG{n}{对于}\PYG{+w}{ }\PYG{n}{QList}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{类型}\PYG{err}{，}\PYG{n}{元素的类型为}\PYG{+w}{ }\PYG{n}{QString}\PYG{err}{。}

\PYG{n}{下列代码展示了如何反向迭代一个}\PYG{+w}{ }\PYG{n}{QList}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{(}\PYG{n}{list}\PYG{p}{);}
\PYG{n}{i}\PYG{p}{.}\PYG{n}{toBack}\PYG{p}{();}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{hasPrevious}\PYG{p}{())}
\PYG{+w}{    }\PYG{n}{qDebug}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{.}\PYG{n}{previous}\PYG{p}{();}

\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{这段代码的逻辑和前向迭代是对称的除了在开始我们调用了}\PYG{+w}{ }\PYG{n}{toBack}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{将迭代器移动到列表中最后一个元素之后}\PYG{err}{。}

\PYG{n}{下图说明了在迭代器上调用}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{previous}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{产生的效果}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{figure}\PYG{p}{\PYGZcb{}[}\PYG{n}{hbt}\PYG{o}{!}\PYG{p}{]}
\PYG{+w}{	}\PYG{err}{\PYGZbs{}}\PYG{n}{centering}
\PYG{+w}{    }\PYG{err}{\PYGZbs{}}\PYG{n}{includegraphics}\PYG{p}{[}\PYG{n}{width}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{err}{\PYGZbs{}}\PYG{n}{textwidth}\PYG{p}{]\PYGZob{}}\PYG{n}{list\PYGZus{}iterator}\PYG{p}{.}\PYG{n}{pdf}\PYG{p}{\PYGZcb{}}
\PYG{+w}{	}\PYG{o}{\PYGZpc{}}\PYG{err}{\PYGZbs{}}\PYG{n}{caption}\PYG{p}{\PYGZob{}}\PYG{n}{model}\PYG{+w}{ }\PYG{n}{index}\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{figure}\PYG{p}{\PYGZcb{}}

\PYG{n}{下表总结了QListIterator的}\PYG{+w}{ }\PYG{n}{API}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{tabular}\PYG{p}{\PYGZcb{}\PYGZob{}}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{函数}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{行为}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{toFront}\PYG{p}{()}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{移动迭代器到列表最前}\PYG{err}{（}\PYG{n}{第一个元素之前}\PYG{err}{）\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{toBack}\PYG{p}{()}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{移动迭代器到列表最后}\PYG{err}{（}\PYG{n}{最后一个元素之后}\PYG{err}{）\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{hasNext}\PYG{p}{()}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{如果迭代器不在列表最后则返回}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{next}\PYG{p}{()}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{返回下一个元素并将迭代器前移一位}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{peekNext}\PYG{p}{()}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{不移动迭代器}\PYG{err}{，}\PYG{n}{仅返回迭代器下一个元素}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{hasPrevious}\PYG{p}{()}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{如果迭代器不在列表最前则返回}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{previous}\PYG{p}{()}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{返回前一个元素并将迭代器后移一位}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{peekPrevious}\PYG{p}{()}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{不移动迭代器}\PYG{err}{，}\PYG{n}{仅返回迭代器前一个元素}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{tabular}\PYG{p}{\PYGZcb{}}

\PYG{n}{QListIterator}\PYG{+w}{ }\PYG{n}{没有提供任何在迭代列表时插入或删除元素的方法}\PYG{err}{。}\PYG{n}{要实现这一}
\PYG{n}{点}\PYG{err}{，}\PYG{n}{你必须使用}\PYG{+w}{ }\PYG{n}{QMutableListIterator}\PYG{err}{。}\PYG{n}{这是一个使用}\PYG{+w}{ }\PYG{n}{QMutableListIterator}
\PYG{n}{从}\PYG{+w}{ }\PYG{n}{QList}\PYG{+w}{ }\PYG{n}{中移除所有奇数的例子}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QMutableListIterator}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{(}\PYG{n}{list}\PYG{p}{);}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{hasNext}\PYG{p}{())}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{next}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{+w}{        }\PYG{n}{i}\PYG{p}{.}\PYG{n}{remove}\PYG{p}{();}
\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{next}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{方法会在每次循环时调用}\PYG{err}{，}\PYG{n}{用于跳过下一个元素}\PYG{err}{。}\PYG{n}{remove}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{方法用于移}
\PYG{n}{除上一个我们跳过的元素}\PYG{err}{。}\PYG{n}{对}\PYG{+w}{ }\PYG{n}{remove}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{方法的调用不会导致迭代器的失效}\PYG{err}{，}\PYG{n}{因}
\PYG{n}{此继续使用迭代器是安全的}\PYG{err}{。}\PYG{n}{这种方式在反向迭代时也是没问题的}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QMutableListIterator}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{(}\PYG{n}{list}\PYG{p}{);}
\PYG{n}{i}\PYG{p}{.}\PYG{n}{toBack}\PYG{p}{();}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{hasPrevious}\PYG{p}{())}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{previous}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{+w}{        }\PYG{n}{i}\PYG{p}{.}\PYG{n}{remove}\PYG{p}{();}
\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{如果仅仅想修改已存在元素的值}\PYG{err}{，}\PYG{n}{我们可以使用}\PYG{+w}{ }\PYG{n}{setValue}\PYG{p}{()}\PYG{err}{。}\PYG{n}{下列代码中}\PYG{err}{，}\PYG{n}{我}
\PYG{n}{们将所有大于}\PYG{+w}{ }\PYG{l+m+mi}{128}\PYG{+w}{ }\PYG{n}{的值替换成}\PYG{+w}{ }\PYG{l+m+mi}{128}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QMutableListIterator}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{(}\PYG{n}{list}\PYG{p}{);}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{hasNext}\PYG{p}{())}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{next}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{128}\PYG{p}{)}
\PYG{+w}{        }\PYG{n}{i}\PYG{p}{.}\PYG{n}{setValue}\PYG{p}{(}\PYG{l+m+mi}{128}\PYG{p}{);}
\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{和}\PYG{+w}{ }\PYG{n}{remove}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{一样}\PYG{err}{，}\PYG{+w}{ }\PYG{n}{setValue}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{对我们跳过的最后一个元素进行操作}\PYG{err}{。}\PYG{n}{如果我们向前迭代}\PYG{err}{，}\PYG{n}{这个元素就是迭代器之前的元素}\PYG{err}{；}\PYG{n}{如果我们向后迭代}\PYG{err}{，}\PYG{n}{这个元素就是迭代器之后的元素}\PYG{err}{。}

\PYG{n}{next}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{方法返回的是列表中元素的非常量引用}\PYG{err}{，}\PYG{n}{对于简单的操作}\PYG{err}{，}\PYG{n}{我们并不需}
\PYG{n}{要调用}\PYG{+w}{ }\PYG{n}{setValue}\PYG{p}{()}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QMutableListIterator}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{(}\PYG{n}{list}\PYG{p}{);}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{hasNext}\PYG{p}{())}
\PYG{+w}{    }\PYG{n}{i}\PYG{p}{.}\PYG{n}{next}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{*=}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{正如上面提到的}\PYG{err}{，}\PYG{n}{QLinkedList}\PYG{err}{，}\PYG{n}{QVector}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QSet}\PYG{+w}{ }\PYG{n}{的迭代器的}\PYG{+w}{ }\PYG{n}{API}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QList}\PYG{+w}{ }\PYG{n}{的完全一致}\PYG{err}{。}\PYG{n}{接下来我们来看看在某些方面不太一样的}\PYG{+w}{ }\PYG{n}{QMapIterator}\PYG{err}{，}\PYG{n}{因为其用于迭代}\PYG{err}{（}\PYG{n}{键}\PYG{err}{，}\PYG{n}{值}\PYG{err}{）}\PYG{n}{对}\PYG{err}{。}

\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QListIterator}\PYG{+w}{ }\PYG{n}{一样}\PYG{err}{，}\PYG{n}{QMapIterator}\PYG{+w}{ }\PYG{n}{提供了}\PYG{+w}{ }\PYG{n}{toFront}\PYG{p}{(),}\PYG{+w}{ }\PYG{n}{toBack}\PYG{p}{(),}\PYG{+w}{ }\PYG{n}{hasNext}\PYG{p}{(),}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(),}\PYG{+w}{ }\PYG{n}{peekNext}\PYG{p}{(),}\PYG{+w}{ }\PYG{n}{hasPrevious}\PYG{p}{(),}\PYG{+w}{ }\PYG{n}{previous}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{peekPrevious}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{方法}\PYG{err}{。}\PYG{n}{我们可以对}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(),}\PYG{+w}{ }\PYG{n}{peekNext}\PYG{p}{(),}\PYG{+w}{ }\PYG{n}{previous}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{或}\PYG{+w}{ }\PYG{n}{peekPrevious}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{返回的对象调用}\PYG{+w}{ }\PYG{n}{key}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{方法来获得键和值}\PYG{err}{。}

\PYG{n}{下列代码用于移除所有首都名以}\PYG{err}{”}\PYG{n}{city}\PYG{err}{“}\PYG{n}{结尾的}\PYG{err}{（}\PYG{n}{首都名}\PYG{err}{，}\PYG{n}{国家名}\PYG{err}{）}\PYG{n}{键值对}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QMap}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{map}\PYG{p}{;}
\PYG{n}{map}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Paris\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}France\PYGZdq{}}\PYG{p}{);}
\PYG{n}{map}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Guatemala City\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Guatemala\PYGZdq{}}\PYG{p}{);}
\PYG{n}{map}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Mexico City\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Mexico\PYGZdq{}}\PYG{p}{);}
\PYG{n}{map}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Moscow\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}Russia\PYGZdq{}}\PYG{p}{);}
\PYG{p}{...}

\PYG{n}{QMutableMapIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{(}\PYG{n}{map}\PYG{p}{);}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{hasNext}\PYG{p}{())}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{next}\PYG{p}{().}\PYG{n}{key}\PYG{p}{().}\PYG{n}{endsWith}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}City\PYGZdq{}}\PYG{p}{))}
\PYG{+w}{        }\PYG{n}{i}\PYG{p}{.}\PYG{n}{remove}\PYG{p}{();}
\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{QMapIterator}\PYG{+w}{ }\PYG{n}{也提供了}\PYG{+w}{ }\PYG{n}{key}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{方法用于操作迭代器及迭代器上一}
\PYG{n}{个跳过的元素的键和值}\PYG{err}{。}\PYG{n}{举个例子}\PYG{err}{，}\PYG{n}{下列代码用于将}\PYG{+w}{ }\PYG{n}{QMap}\PYG{+w}{ }\PYG{n}{的内容拷贝到}\PYG{+w}{ }\PYG{n}{QHash}
\PYG{n}{中}\PYG{err}{。}


\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QMap}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QWidget}\PYG{+w}{ }\PYG{o}{*\PYGZgt{}}\PYG{+w}{ }\PYG{n}{map}\PYG{p}{;}
\PYG{n}{QHash}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QWidget}\PYG{+w}{ }\PYG{o}{*\PYGZgt{}}\PYG{+w}{ }\PYG{n}{hash}\PYG{p}{;}

\PYG{n}{QMapIterator}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QWidget}\PYG{+w}{ }\PYG{o}{*\PYGZgt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{(}\PYG{n}{map}\PYG{p}{);}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{hasNext}\PYG{p}{())}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{i}\PYG{p}{.}\PYG{n}{next}\PYG{p}{();}
\PYG{+w}{    }\PYG{n}{hash}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{key}\PYG{p}{(),}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{.}\PYG{n}{value}\PYG{p}{());}
\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{如果想要迭代遍历所有值相同的元素}\PYG{err}{，}\PYG{n}{我们可以使用}\PYG{+w}{ }\PYG{n}{findNext}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{和}
\PYG{n}{findPrevious}\PYG{p}{()}\PYG{err}{。}\PYG{n}{这里的例子用于移除带有指定值的元素}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QMutableMapIterator}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QWidget}\PYG{+w}{ }\PYG{o}{*\PYGZgt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{(}\PYG{n}{map}\PYG{p}{);}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{findNext}\PYG{p}{(}\PYG{n}{widget}\PYG{p}{))}
\PYG{+w}{    }\PYG{n}{i}\PYG{p}{.}\PYG{n}{remove}\PYG{p}{();}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{err}{\PYGZbs{}}\PYG{n}{splitLine}

\PYG{err}{\PYGZbs{}}\PYG{n}{section}\PYG{p}{\PYGZob{}}\PYG{n}{STL}\PYG{+w}{ }\PYG{n}{风格迭代器}\PYG{p}{\PYGZcb{}}

\PYG{n}{STL}\PYG{+w}{ }\PYG{n}{风格迭代器在}\PYG{+w}{ }\PYG{n}{Qt}\PYG{+w}{ }\PYG{l+m+mf}{2.0}\PYG{+w}{ }\PYG{n}{中被引入}\PYG{err}{，}\PYG{n}{可用于}\PYG{+w}{ }\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{STL}\PYG{+w}{ }\PYG{n}{的泛型算法}\PYG{err}{，}\PYG{n}{且为速度做了优化}\PYG{err}{。}

\PYG{n}{对于每一个容器类}\PYG{err}{，}\PYG{n}{同时提供了两种类型的}\PYG{+w}{ }\PYG{n}{STL}\PYG{+w}{ }\PYG{n}{风格迭代器}\PYG{err}{：}\PYG{n}{一种支持只读访}
\PYG{n}{问}\PYG{err}{，}\PYG{n}{另一种支持读写访问}\PYG{err}{。}


\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{tabular}\PYG{p}{\PYGZcb{}\PYGZob{}}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{容器}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{只读迭代器}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{只写迭代器}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QList}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QQueue}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{QList}\PYG{o}{::}\PYG{k}{const}\PYG{err}{\PYGZbs{}}\PYG{n}{\PYGZus{}iterator}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{QList}\PYG{o}{::}\PYG{n}{iterator}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QLinkedList}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{QLinkedList}\PYG{o}{::}\PYG{k}{const}\PYG{err}{\PYGZbs{}}\PYG{n}{\PYGZus{}iterator}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{QLinkedList}\PYG{o}{::}\PYG{n}{iterator}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QVector}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QStack}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{QVector}\PYG{o}{::}\PYG{k}{const}\PYG{err}{\PYGZbs{}}\PYG{n}{\PYGZus{}iterator}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{QVector}\PYG{o}{::}\PYG{n}{iterator}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QSet}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{QSet}\PYG{o}{::}\PYG{k}{const}\PYG{err}{\PYGZbs{}}\PYG{n}{\PYGZus{}iterator}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{QSet}\PYG{o}{::}\PYG{n}{iterator}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QMap}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QMultiMap}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{+w}{	}\PYG{n}{QMap}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}::}\PYG{k}{const}\PYG{err}{\PYGZbs{}}\PYG{n}{\PYGZus{}iterator}
\PYG{+w}{                   }\PYG{o}{\PYGZam{}}\PYG{n}{QMap}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}::}\PYG{n}{iterator}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QHash}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QMultiHash}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{+w}{	}\PYG{n}{QHash}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}::}\PYG{k}{const}\PYG{err}{\PYGZbs{}}\PYG{n}{\PYGZus{}iterator}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{QHash}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}::}\PYG{n}{iterator}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{tabular}\PYG{p}{\PYGZcb{}}

\PYG{n}{STL}\PYG{+w}{ }\PYG{n}{风格迭代器的}\PYG{+w}{ }\PYG{n}{API}\PYG{+w}{ }\PYG{n}{以}\PYG{+w}{ }\PYG{n}{数组指针为原型设计}\PYG{err}{。}\PYG{n}{例如}\PYG{err}{，}\PYG{o}{++}\PYG{+w}{ }\PYG{n}{运算符将迭代器向前移动至下一个元素}\PYG{err}{，}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{运算符返回迭代器指向的元素}\PYG{err}{。}\PYG{n}{实际上}\PYG{err}{，}\PYG{n}{对于}\PYG{+w}{ }\PYG{n}{QVector}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QStack}\PYG{+w}{ }\PYG{n}{这类元素存储在连续内存的容器来说}\PYG{err}{，}\PYG{n}{iterator}\PYG{+w}{ }\PYG{n}{类型仅仅是}\PYG{+w}{ }\PYG{n}{T}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{的别名}\PYG{err}{，}\PYG{k}{const}\PYG{err}{\PYGZbs{}}\PYG{n}{\PYGZus{}iterator}\PYG{+w}{ }\PYG{n}{是}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{T}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{的一个别名}\PYG{err}{。}

\PYG{n}{在接下来的讨论中}\PYG{err}{，}\PYG{n}{我们将重点关注}\PYG{+w}{ }\PYG{n}{QList}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QMap}\PYG{err}{。}\PYG{n}{QLinkedList}\PYG{err}{，}\PYG{n}{QVector}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QSet}\PYG{+w}{ }\PYG{n}{的迭代器类型和QList有完全一样的接口}\PYG{err}{，}\PYG{n}{类似的}\PYG{err}{，}\PYG{n}{QHash}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QMap}\PYG{+w}{ }\PYG{n}{的迭代器类型的接口也是相同的}\PYG{err}{。}

\PYG{n}{这是一个通过循环迭代有序遍历}\PYG{+w}{ }\PYG{n}{QList}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{中的所有元素并将它们转成小}
\PYG{n}{写的常见写法}\PYG{err}{：}


\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QList}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{;}
\PYG{n}{list}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}A\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}B\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}C\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}D\PYGZdq{}}\PYG{p}{;}

\PYG{n}{QList}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}::}\PYG{n}{iterator}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{();}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{.}\PYG{n}{end}\PYG{p}{();}\PYG{+w}{ }\PYG{o}{++}\PYG{n}{i}\PYG{p}{)}
\PYG{+w}{    }\PYG{o}{*}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{i}\PYG{p}{).}\PYG{n}{toLower}\PYG{p}{();}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{和}\PYG{+w}{ }\PYG{n}{Java}\PYG{+w}{ }\PYG{n}{风格迭代器不同}\PYG{err}{，}\PYG{n}{STL}\PYG{+w}{ }\PYG{n}{风格迭代器直接指向元素本身}\PYG{err}{。}\PYG{n}{容器的}\PYG{+w}{ }\PYG{n}{begin}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{方法会返回一个指向容器第一个元素的迭代器}\PYG{err}{，}\PYG{n}{end}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{方法返回的迭代器指向一个虚拟的元素}\PYG{err}{，}\PYG{n}{该元素位于容器最后一个元素的下一个位置}\PYG{err}{。}\PYG{n}{end}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{标记了一个非法的位置}\PYG{err}{，}\PYG{n}{永远不要对其解引用}\PYG{err}{。}\PYG{n}{其通常被用作循环的结束条件}\PYG{err}{。}\PYG{n}{对于空列表}\PYG{err}{，}\PYG{n}{begin}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{end}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{是相等的}\PYG{err}{，}\PYG{n}{因此我们永远不会执行循环}\PYG{err}{。}

\PYG{n}{下图用红色箭头展示了一个四个元素的列表容器中合法的迭代器位置}\PYG{err}{。}
\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{figure}\PYG{p}{\PYGZcb{}[}\PYG{n}{hpt}\PYG{o}{!}\PYG{p}{]}
\PYG{+w}{	}\PYG{err}{\PYGZbs{}}\PYG{n}{centering}
\PYG{+w}{    }\PYG{err}{\PYGZbs{}}\PYG{n}{includegraphics}\PYG{p}{[}\PYG{n}{width}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{err}{\PYGZbs{}}\PYG{n}{textwidth}\PYG{p}{]\PYGZob{}}\PYG{n}{stl\PYGZus{}style\PYGZus{}iterator}\PYG{p}{.}\PYG{n}{pdf}\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{figure}\PYG{p}{\PYGZcb{}}

\PYG{n}{使用}\PYG{+w}{ }\PYG{n}{STL}\PYG{+w}{ }\PYG{n}{风格迭代器反向遍历可以通过反向迭代器实现}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QList}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{;}
\PYG{n}{list}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}A\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}B\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}C\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}D\PYGZdq{}}\PYG{p}{;}

\PYG{n}{QList}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}::}\PYG{n}{reverse\PYGZus{}iterator}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{.}\PYG{n}{rbegin}\PYG{p}{();}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{.}\PYG{n}{rend}\PYG{p}{();}\PYG{+w}{ }\PYG{o}{++}\PYG{n}{i}\PYG{p}{)}
\PYG{+w}{    }\PYG{o}{*}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{toLower}\PYG{p}{();}
\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{上面的代码片段中}\PYG{err}{，}\PYG{n}{我们通过一元运算符}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{来获取保存在指定迭代器位置的元素}\PYG{err}{（}\PYG{n}{此处类型为QString}\PYG{err}{），}\PYG{n}{并对其调用了}\PYG{+w}{ }\PYG{n}{QString}\PYG{o}{::}\PYG{n}{toLower}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{方法}\PYG{err}{。}\PYG{n}{大部分}\PYG{+w}{ }\PYG{n}{C}\PYG{o}{++}\PYG{+w}{ }\PYG{n}{编译器也同时支持i}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{toLower}\PYG{p}{()}\PYG{n}{这种写法}\PYG{err}{，}\PYG{n}{但也有一些不支持}\PYG{err}{。}

\PYG{n}{对于只读访问}\PYG{err}{，}\PYG{n}{你可以使用}\PYG{+w}{ }\PYG{k}{const}\PYG{err}{\PYGZbs{}}\PYG{n}{\PYGZus{}iterator}\PYG{+w}{ }\PYG{p}{,}\PYG{+w}{ }\PYG{n}{constBegin}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{constEnd}\PYG{p}{()}\PYG{err}{。}
\PYG{n}{例如}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QList}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}::}\PYG{n}{const\PYGZus{}iterator}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{.}\PYG{n}{constBegin}\PYG{p}{();}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{.}\PYG{n}{constEnd}\PYG{p}{();}\PYG{+w}{ }\PYG{o}{++}\PYG{n}{i}\PYG{p}{)}
\PYG{+w}{    }\PYG{n}{qDebug}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{i}\PYG{p}{;}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{下表整理了}\PYG{+w}{ }\PYG{n}{STL}\PYG{+w}{ }\PYG{n}{风格迭代器的}\PYG{+w}{ }\PYG{n}{API}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{tabular}\PYG{p}{\PYGZcb{}\PYGZob{}}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{表达式}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{行为}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{o}{*}\PYG{n}{i}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{返回当前元素}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{o}{++}\PYG{n}{i}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{向前移动迭代器至下一元素}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{向前移动迭代器}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{n}{次}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{n}{i}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{向后移动迭代器至前一个元素}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}=}\PYG{+w}{ }\PYG{n}{n}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{向后移动迭代器}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{n}{次}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{返回迭代器}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{n}{间隔的元素个数}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{tabular}\PYG{p}{\PYGZcb{}}

\PYG{err}{\PYGZbs{}}\PYG{n}{hl}\PYG{p}{\PYGZob{}}\PYG{o}{++}\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{err}{\PYGZbs{}}\PYG{n}{hl}\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{n}{运算符既可以作为前缀}\PYG{p}{(}\PYG{+w}{ }\PYG{err}{\PYGZbs{}}\PYG{n}{hl}\PYG{p}{\PYGZob{}}\PYG{o}{++}\PYG{n}{i}\PYG{p}{\PYGZcb{}}\PYG{err}{，\PYGZbs{}}\PYG{n}{hl}\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{n}{i}\PYG{p}{\PYGZcb{})}\PYG{+w}{ }\PYG{err}{，}\PYG{n}{也可以}
\PYG{n}{作为后缀}\PYG{err}{（\PYGZbs{}}\PYG{n}{hl}\PYG{p}{\PYGZob{}}\PYG{n}{i}\PYG{o}{++}\PYG{p}{\PYGZcb{}}\PYG{err}{，\PYGZbs{}}\PYG{n}{hl}\PYG{p}{\PYGZob{}}\PYG{n}{i}\PYG{o}{\PYGZhy{}\PYGZhy{}}\PYG{p}{\PYGZcb{}}\PYG{err}{）}\PYG{n}{运算符}\PYG{err}{。}\PYG{n}{前缀版本先修改迭代器}\PYG{err}{，}\PYG{n}{然后返回修改后的迭代器的引用}\PYG{err}{。}\PYG{n}{后缀版本在修改迭代器之前先将其复制一份}\PYG{err}{，}\PYG{n}{然后返回副本}\PYG{err}{。}\PYG{n}{在返回值被忽略的表达式中}\PYG{err}{，}\PYG{n}{我们建议使用前缀版本}\PYG{err}{，}\PYG{n}{因为这样会略快一点}\PYG{err}{。}

\PYG{n}{对于非常量迭代器类型}\PYG{err}{，}\PYG{n}{一元运算符}\PYG{+w}{ }\PYG{err}{\PYGZbs{}}\PYG{n}{hl}\PYG{p}{\PYGZob{}}\PYG{o}{*}\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{n}{的返回值可以作为赋值运算符的左侧}\PYG{err}{。}

\PYG{n}{对于}\PYG{+w}{ }\PYG{n}{QMap}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QHash}\PYG{err}{，\PYGZbs{}}\PYG{n}{hl}\PYG{p}{\PYGZob{}}\PYG{o}{*}\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{n}{运算符返回一个元素的值}\PYG{err}{，}\PYG{n}{如果你想获取键}\PYG{err}{，}\PYG{n}{可以调用}
\PYG{n}{迭代器的}\PYG{+w}{ }\PYG{n}{key}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{方法}\PYG{err}{。}\PYG{n}{相对应的}\PYG{err}{，}\PYG{n}{迭代器类型也提供了}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{用于获取值}\PYG{err}{。}
\PYG{n}{下面是一个将}\PYG{+w}{ }\PYG{n}{QMap}\PYG{+w}{ }\PYG{n}{中所有元素打印到终端的例子}\PYG{err}{：}


\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QMap}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{map}\PYG{p}{;}
\PYG{p}{...}
\PYG{n}{QMap}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}::}\PYG{n}{const\PYGZus{}iterator}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{map}\PYG{p}{.}\PYG{n}{constBegin}\PYG{p}{();}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{map}\PYG{p}{.}\PYG{n}{constEnd}\PYG{p}{();}\PYG{+w}{ }\PYG{o}{++}\PYG{n}{i}\PYG{p}{)}
\PYG{+w}{    }\PYG{n}{qDebug}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{.}\PYG{n}{key}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}:\PYGZsq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{.}\PYG{n}{value}\PYG{p}{();}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{正是因为隐式共享}\PYG{err}{，}\PYG{n}{调用一个返回容器的函数的开销不会很大}\PYG{err}{。}\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{API}\PYG{+w}{ }\PYG{n}{中包含几十个返回值为}\PYG{+w}{ }\PYG{n}{QList}\PYG{+w}{ }\PYG{n}{或}\PYG{+w}{ }\PYG{n}{QStringList}\PYG{+w}{ }\PYG{n}{的函数}\PYG{err}{（}\PYG{n}{例如}\PYG{+w}{ }\PYG{n}{QSplitter}\PYG{o}{::}\PYG{n}{sizes}\PYG{p}{()}\PYG{+w}{ }\PYG{err}{）。}\PYG{n}{如果需要通过}\PYG{+w}{ }\PYG{n}{STL}\PYG{+w}{ }\PYG{n}{迭代器遍历这些返回值}\PYG{err}{，}\PYG{n}{你应当总是将返回的容器复制一份然后迭代其副本}\PYG{err}{。}\PYG{n}{例如}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// 正确}
\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QList}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{sizes}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{splitter}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{sizes}\PYG{p}{();}
\PYG{n}{QList}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}::}\PYG{n}{const\PYGZus{}iterator}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sizes}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{();}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{sizes}\PYG{p}{.}\PYG{n}{end}\PYG{p}{();}\PYG{+w}{ }\PYG{o}{++}\PYG{n}{i}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{...}

\PYG{c+c1}{// 错误}
\PYG{n}{QList}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}::}\PYG{n}{const\PYGZus{}iterator}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{splitter}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{sizes}\PYG{p}{().}\PYG{n}{begin}\PYG{p}{();}
\PYG{+w}{        }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{splitter}\PYG{o}{\PYGZhy{}\PYGZgt{}}\PYG{n}{sizes}\PYG{p}{().}\PYG{n}{end}\PYG{p}{();}\PYG{+w}{ }\PYG{o}{++}\PYG{n}{i}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{...}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{如果函数返回的是一个容器的常量或非常量引用}\PYG{err}{，}\PYG{n}{那么是不存在这个问题的}\PYG{err}{。}

\PYG{n}{隐式共享迭代器问题}

\PYG{n}{隐式共享给}\PYG{+w}{ }\PYG{n}{STL}\PYG{+w}{ }\PYG{n}{风格迭代器带来了另一个后果是}\PYG{err}{：}\PYG{n}{当一个容器的迭代器在使用}
\PYG{n}{时你应当避免复制该容器}\PYG{err}{。}\PYG{n}{迭代器指向了一个内部结构}\PYG{err}{，}\PYG{n}{当你复制容器时你需要}
\PYG{n}{特别小心的处理迭代器}\PYG{err}{。}\PYG{n}{比如}\PYG{err}{：}


\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QVector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{;}
\PYG{n}{a}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{l+m+mi}{100000}\PYG{p}{);}\PYG{+w}{ }\PYG{c+c1}{// 创建一个填充0的大数组.}

\PYG{n}{QVector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}::}\PYG{n}{iterator}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{();}
\PYG{c+c1}{// 迭代器i的错误用法:}
\PYG{n}{b}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{c+cm}{/*}
\PYG{c+cm}{    现在我们应当小心地使用迭代器`i`，因为 i 指向的是共享的数据。}
\PYG{c+cm}{    如果我们执行 *i = 4 那么我们可能改变共享的实例（两个数组共享）}
\PYG{c+cm}{    这个行为和 STL 容器是不同的。在 Qt 中不要这样做。}
\PYG{c+cm}{*/}

\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{c+cm}{/*}
\PYG{c+cm}{    容器 a 现在已经和共享数据脱离，}
\PYG{c+cm}{    即使 i 之前是容器 a 的迭代器，但现在它是作为 b 的迭代器而存在。}
\PYG{c+cm}{    此时 (*i) == 0}
\PYG{c+cm}{*/}

\PYG{n}{b}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{();}\PYG{+w}{ }\PYG{c+c1}{// 此时 i 彻底失效}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{i}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// 未定义行为!}
\PYG{c+cm}{/*}
\PYG{c+cm}{    b 中的数据（即i 指向的）已经被释放，}
\PYG{c+cm}{    在 STL 容器中这是有明确定义的（(*i) == 5），}
\PYG{c+cm}{    但对于 QVector 来说这样做很有可能导致崩溃。}
\PYG{c+cm}{*/}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{quote}\PYG{p}{\PYGZcb{}}
\PYG{n}{译注}\PYG{err}{：}\PYG{n}{STL}\PYG{+w}{ }\PYG{n}{容器std}\PYG{o}{::}\PYG{n}{vector在调用clear}\PYG{p}{()}\PYG{n}{方法后内存不会被释放}\PYG{err}{，}\PYG{n}{因此迭代器并不会立即失效}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{quote}\PYG{p}{\PYGZcb{}}

\PYG{n}{上面的例子仅仅说明了QVector的问题}\PYG{err}{，}\PYG{n}{但实际上所有支持隐式共享的容器都存在该问题}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{splitLine}

\PYG{n}{foreach}\PYG{+w}{ }\PYG{n}{关键字}

\PYG{n}{如果仅仅是需要有序迭代容器中的每个元素}\PYG{err}{，}\PYG{n}{你可以使用}\PYG{+w}{ }\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{提供的关键字}\PYG{+w}{ }\PYG{n}{foreach}\PYG{err}{。}\PYG{n}{这个关键字对}\PYG{+w}{ }\PYG{n}{C}\PYG{o}{++}\PYG{+w}{ }\PYG{n}{语言的一个特定于}\PYG{+w}{ }\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{的补充}\PYG{err}{，}\PYG{n}{其通过预处理器实现}\PYG{err}{。}

\PYG{n}{使用的语法是}\PYG{err}{：}\PYG{n}{foreach}\PYG{p}{(}\PYG{n}{变量}\PYG{err}{，}\PYG{n}{容器}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{语句}\PYG{err}{。}\PYG{n}{下面是一个使用}\PYG{+w}{ }\PYG{n}{foreach}\PYG{+w}{ }\PYG{n}{迭代}\PYG{+w}{ }\PYG{n}{QLinkedList}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{的例子}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}

\PYG{n}{QLinkedList}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{;}
\PYG{p}{...}
\PYG{n}{QString}\PYG{+w}{ }\PYG{n}{str}\PYG{p}{;}
\PYG{n}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{str}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{)}
\PYG{+w}{    }\PYG{n}{qDebug}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{n}{str}\PYG{p}{;}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{和使用迭代器实现相同功能的代码相比}\PYG{err}{，}\PYG{n}{使用foreach的代码明显简洁很多}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QLinkedList}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{;}
\PYG{p}{...}
\PYG{n}{QLinkedListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{(}\PYG{n}{list}\PYG{p}{);}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{.}\PYG{n}{hasNext}\PYG{p}{())}
\PYG{+w}{    }\PYG{n}{qDebug}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{.}\PYG{n}{next}\PYG{p}{();}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{除了数据类型包含逗号}\PYG{err}{（}\PYG{n}{例如}\PYG{+w}{ }\PYG{n}{QPair}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{err}{）}\PYG{n}{以外}\PYG{err}{，}\PYG{n}{用于迭代的变量可以在}\PYG{+w}{ }\PYG{n}{foreach}\PYG{+w}{ }\PYG{n}{语句中被定义}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QLinkedList}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{;}
\PYG{p}{...}
\PYG{n}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QString}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{str}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{)}
\PYG{+w}{    }\PYG{n}{qDebug}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{n}{str}\PYG{p}{;}
\PYG{n}{和其他}\PYG{+w}{ }\PYG{n}{C}\PYG{o}{++}\PYG{+w}{ }\PYG{n}{循环结构类似}\PYG{err}{，}\PYG{n}{你可以使用大括号将循环体包围}\PYG{err}{，}\PYG{n}{也可以使用}\PYG{+w}{ }\PYG{k}{break}\PYG{+w}{ }\PYG{n}{跳出循环}\PYG{err}{。}

\PYG{n}{QLinkedList}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{;}
\PYG{p}{...}
\PYG{n}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QString}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{str}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{list}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{str}\PYG{p}{.}\PYG{n}{isEmpty}\PYG{p}{())}
\PYG{+w}{        }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{qDebug}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{n}{str}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{对于}\PYG{+w}{ }\PYG{n}{QMap}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QHash}\PYG{err}{，}\PYG{n}{foreach}\PYG{+w}{ }\PYG{n}{会自动访问}\PYG{err}{（}\PYG{n}{键}\PYG{err}{，}\PYG{n}{值}\PYG{err}{）}\PYG{n}{对中的值}\PYG{err}{，}\PYG{n}{因此你不需要再调用容器的}\PYG{+w}{ }\PYG{n}{values}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{方法}\PYG{err}{（}\PYG{n}{这样可能会产生不必要的复制}\PYG{err}{，}\PYG{n}{见后续说明}\PYG{err}{）。}\PYG{n}{如果你想要同时迭代键和值}\PYG{err}{，}\PYG{n}{可以使用迭代器}\PYG{err}{（}\PYG{n}{会更快}\PYG{err}{），}\PYG{n}{或者也可以先获取所有的键}\PYG{err}{，}\PYG{n}{再通过它们获取对应的值}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QMap}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{map}\PYG{p}{;}
\PYG{p}{...}
\PYG{n}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QString}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{str}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{map}\PYG{p}{.}\PYG{n}{keys}\PYG{p}{())}
\PYG{+w}{    }\PYG{n}{qDebug}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{n}{str}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}:\PYGZsq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{n}{map}\PYG{p}{.}\PYG{n}{value}\PYG{p}{(}\PYG{n}{str}\PYG{p}{);}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}


\PYG{n}{对于一个多值映射}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QMultiMap}\PYG{o}{\PYGZlt{}}\PYG{n}{QString}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{map}\PYG{p}{;}
\PYG{p}{...}
\PYG{n}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QString}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{str}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{map}\PYG{p}{.}\PYG{n}{uniqueKeys}\PYG{p}{())}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{foreach}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{map}\PYG{p}{.}\PYG{n}{values}\PYG{p}{(}\PYG{n}{str}\PYG{p}{))}
\PYG{+w}{        }\PYG{n}{qDebug}\PYG{p}{()}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{n}{str}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}:\PYGZsq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{当进入一个}\PYG{+w}{ }\PYG{n}{foreach}\PYG{+w}{ }\PYG{n}{循环}\PYG{err}{，}\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{会自动产生一个容器的副本}\PYG{err}{。}\PYG{n}{如果在迭代过程中修改了容器}\PYG{err}{，}\PYG{n}{并不会影响到这次循环}\PYG{err}{。（}\PYG{n}{如果没有修改容器}\PYG{err}{，}\PYG{n}{副本依然会占用空间}\PYG{err}{，}\PYG{n}{但由于隐式共享的缘故}\PYG{err}{，}\PYG{n}{复制一个容器是非常快的}\PYG{err}{）。}

\PYG{n}{因为}\PYG{+w}{ }\PYG{n}{foreach}\PYG{+w}{ }\PYG{n}{会产生容器的副本}\PYG{err}{，}\PYG{n}{使用是个变量的非常量引用也是无法修改原容器的}\PYG{err}{，}\PYG{n}{它仅仅会影响副本}\PYG{err}{，}\PYG{n}{这可能不是你想要的}\PYG{err}{。}

\PYG{n}{一个对}\PYG{+w}{ }\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{的}\PYG{+w}{ }\PYG{n}{foreach}\PYG{+w}{ }\PYG{n}{循环的替代方案是}\PYG{+w}{ }\PYG{n}{C}\PYG{o}{++}\PYG{+w}{ }\PYG{l+m+mi}{11}\PYG{+w}{ }\PYG{n}{或更新标准中引入的基于范围的}\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }\PYG{n}{循环}\PYG{err}{。}\PYG{n}{然而}\PYG{err}{，}\PYG{n}{基于范围的}\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }\PYG{n}{循环可能强行导致}\PYG{+w}{ }\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{容器脱离}\PYG{err}{，}\PYG{n}{但}\PYG{+w}{ }\PYG{n}{foreach}\PYG{+w}{ }\PYG{n}{不会}\PYG{err}{。}\PYG{n}{由于使用}\PYG{+w}{ }\PYG{n}{foreach}\PYG{+w}{ }\PYG{n}{总是会复制一份容器}\PYG{err}{，}\PYG{n}{对}\PYG{+w}{ }\PYG{n}{STL}\PYG{+w}{ }\PYG{n}{容器来说这通常会导致一定的开销}\PYG{err}{。}\PYG{n}{如果不知道用哪个}\PYG{err}{，}\PYG{n}{建议对}\PYG{+w}{ }\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{容器选择}\PYG{+w}{ }\PYG{n}{foreach}\PYG{err}{，}\PYG{n}{而对}\PYG{+w}{ }\PYG{n}{STL}\PYG{+w}{ }\PYG{n}{容器选择基于范围的}\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }\PYG{n}{循环}\PYG{err}{。}

\PYG{n}{除了}\PYG{+w}{ }\PYG{n}{foreach}\PYG{err}{，}\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{还提供了一个}\PYG{+w}{ }\PYG{n}{forever}\PYG{+w}{ }\PYG{n}{伪关键字用于执行无限循环}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{forever}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{p}{...}
\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{如果你担心命名空间污染}\PYG{err}{，}\PYG{n}{你可以在}\PYG{+w}{ }\PYG{p}{.}\PYG{n}{pro}\PYG{+w}{ }\PYG{n}{文件中添加以下代码以禁用这些宏}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{CONFIG}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{n}{no\PYGZus{}keywords}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{err}{\PYGZbs{}}\PYG{n}{splitLine}

\PYG{n}{其他类似容器类}

\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{包含了在某些方面和容器相似的其他模板类}\PYG{err}{。}\PYG{n}{这些类没有提供迭代器}\PYG{err}{，}\PYG{n}{也无}
\PYG{n}{法在}\PYG{+w}{ }\PYG{err}{\PYGZbs{}}\PYG{n}{hl}\PYG{p}{\PYGZob{}}\PYG{n}{foreach}\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{n}{关键字中使用}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{compactitem}\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{item}\PYG{+w}{ }\PYG{n}{QCache}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{提供了一个缓存}\PYG{err}{，}\PYG{n}{用于保存与键类型Key相关联的类型T的对象}\PYG{err}{。}
\PYG{err}{\PYGZbs{}}\PYG{n}{item}\PYG{+w}{ }\PYG{n}{QContiguousCache}\PYG{+w}{ }\PYG{n}{提供了一个高效的方式用于缓存那些通常以连续的方式访问的数据}\PYG{err}{。}
\PYG{err}{\PYGZbs{}}\PYG{n}{item}\PYG{+w}{ }\PYG{n}{QPair}\PYG{o}{\PYGZlt{}}\PYG{n}{T1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T2}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{保存了一对元素}\PYG{err}{。}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{compactitem}\PYG{p}{\PYGZcb{}}

\PYG{n}{其他基于}\PYG{+w}{ }\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{的模板容器实现的非模板类型有}\PYG{+w}{ }\PYG{n}{QBitArray}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QByteArray}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QString}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QStringList}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{splitLine}

\PYG{err}{\PYGZbs{}}\PYG{n}{section}\PYG{p}{\PYGZob{}}\PYG{n}{算法复杂度}\PYG{p}{\PYGZcb{}}

\PYG{n}{算法复杂度关注的是当容器中元素数量增加时}\PYG{err}{，}\PYG{n}{每个函数有多快}\PYG{err}{（}\PYG{n}{或者说多慢}\PYG{err}{）。}\PYG{n}{例如}\PYG{err}{，}\PYG{n}{无论}\PYG{+w}{ }\PYG{n}{QLinkedList}\PYG{+w}{ }\PYG{n}{中的元素数量有多少}\PYG{err}{，}\PYG{n}{在其中间插入一个元素是一个极快的操作}\PYG{err}{，}\PYG{n}{然而在一个具有非常多的元素的}\PYG{+w}{ }\PYG{n}{QVector}\PYG{+w}{ }\PYG{n}{中间插入一个元素可能会非常慢}\PYG{err}{，}\PYG{n}{因为半数的元素需要在内存中移动一个位置}\PYG{err}{。}

\PYG{n}{为了描述算法复杂度}\PYG{err}{，}\PYG{n}{我们使用以下基于}\PYG{err}{“}\PYG{n}{大O}\PYG{err}{”}\PYG{n}{符号的术语}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{compactitem}\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{item}\PYG{+w}{ }\PYG{n}{常量时间}\PYG{err}{：}\PYG{n}{O}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{err}{。}\PYG{n}{函数有常量时间复杂度表示无论容器中有多少元素}\PYG{err}{，}\PYG{n}{执行该函数的时间都是相等的}\PYG{err}{。}\PYG{n}{一个例子是}\PYG{+w}{ }\PYG{n}{QLinkedList}\PYG{o}{::}\PYG{n}{insert}\PYG{p}{())}\PYG{err}{；}
\PYG{err}{\PYGZbs{}}\PYG{n}{item}\PYG{+w}{ }\PYG{n}{对数时间}\PYG{err}{：}\PYG{n}{O}\PYG{p}{(}\PYG{n}{log}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{err}{。}\PYG{n}{函数有对数时间复杂度表示该函数的运行时间和容器中元素个数的对数成正比}\PYG{err}{。}\PYG{n}{一个例子是二分查找算法}\PYG{err}{。}
\PYG{err}{\PYGZbs{}}\PYG{n}{item}\PYG{+w}{ }\PYG{n}{线性时间}\PYG{err}{：}\PYG{n}{O}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{err}{。}\PYG{n}{函数有线性时间复杂度表示该函数的运行时间和容器中元素的个数成正比}\PYG{err}{。}\PYG{n}{一个例子是}\PYG{+w}{ }\PYG{n}{QVector}\PYG{o}{::}\PYG{n}{insert}\PYG{p}{()}\PYG{err}{。}
\PYG{err}{\PYGZbs{}}\PYG{n}{item}\PYG{+w}{ }\PYG{n}{线性对数时间}\PYG{err}{：}\PYG{n}{O}\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{n}{log}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{err}{。}\PYG{n}{线性对数时间复杂度的函数要比线性复杂度的函数慢}\PYG{err}{，}\PYG{n}{且随着数量的增加差距会越来越大}\PYG{err}{，}\PYG{n}{但依然比平方时间的函数快}\PYG{err}{。}
\PYG{err}{\PYGZbs{}}\PYG{n}{item}\PYG{+w}{ }\PYG{n}{平方时间}\PYG{err}{：}\PYG{n}{O}\PYG{p}{(}\PYG{n}{n²}\PYG{p}{)}\PYG{err}{。}\PYG{n}{函数有平方时间复杂度表示该函数的运行时间和容器中元素的个数的平方成正比}\PYG{err}{。}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{compactitem}\PYG{p}{\PYGZcb{}}

\PYG{n}{下表总结了}\PYG{+w}{ }\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{线性容器类的算法复杂度}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{tabular}\PYG{p}{\PYGZcb{}\PYGZob{}}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{o}{\PYGZam{}}\PYG{n}{线性查找}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{插入}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{头部追加}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{尾部追加}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QLinkedList}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QList}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{Amort}\PYG{p}{.}\PYG{+w}{ }\PYG{n}{O}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{Amort}\PYG{p}{.}\PYG{+w}{ }\PYG{n}{O}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QVector}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{Amort}\PYG{p}{.}\PYG{+w}{ }\PYG{n}{O}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{Amort}\PYG{p}{.}\PYG{+w}{ }\PYG{n}{O}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{tabular}\PYG{p}{\PYGZcb{}}

\PYG{n}{表中的}\PYG{+w}{ }\PYG{err}{“}\PYG{n}{Amort}\PYG{p}{.}\PYG{+w}{ }\PYG{err}{”}\PYG{+w}{ }\PYG{n}{表示}\PYG{err}{“}\PYG{n}{均摊行为}\PYG{err}{”。}\PYG{n}{例如}\PYG{err}{，“}\PYG{n}{Amort}\PYG{p}{.}\PYG{+w}{ }\PYG{n}{O}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{err}{”}\PYG{+w}{ }\PYG{n}{表示如果仅调用一次该方法}\PYG{err}{，}\PYG{n}{你可能耗费}\PYG{+w}{ }\PYG{n}{O}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{的时间}\PYG{err}{，}\PYG{n}{但如果多次调用}\PYG{err}{（}\PYG{n}{假设调用}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{n}{次}\PYG{err}{），}\PYG{n}{平均下来复杂度将会是}\PYG{+w}{ }\PYG{n}{O}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{err}{。}

\PYG{n}{下表总结了}\PYG{+w}{ }\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{关联容器的算法复杂度}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{tabular}\PYG{p}{\PYGZcb{}\PYGZob{}}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{n}{l}\PYG{o}{|}\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{o}{\PYGZam{}}\PYG{n}{查找键}\PYG{+w}{	}\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{	}\PYG{n}{插入}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{o}{\PYGZam{}}\PYG{n}{平均}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{最坏情况}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{平均}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{最坏情况}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QMap}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{n}{log}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{n}{log}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{n}{log}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{n}{log}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QMultiMap}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{n}{log}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{O}\PYG{p}{(}\PYG{n}{log}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{n}{log}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{n}{log}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QHash}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}\PYGZam{}}\PYG{+w}{	}\PYG{n}{Amort}\PYG{p}{.}\PYG{+w}{ }\PYG{n}{O}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{Amort}\PYG{p}{.}\PYG{+w}{ }\PYG{n}{O}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{n}{QSet}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{Amort}\PYG{p}{.}\PYG{+w}{ }\PYG{n}{O}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{+w}{	}\PYG{n}{O}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{Amort}\PYG{p}{.}\PYG{+w}{ }\PYG{n}{O}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{	}\PYG{o}{\PYGZam{}}\PYG{n}{O}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{err}{\PYGZbs{}}\PYGZbs{}
\PYG{err}{\PYGZbs{}}\PYG{n}{hline}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{tabular}\PYG{p}{\PYGZcb{}}

\PYG{n}{对于}\PYG{+w}{ }\PYG{n}{QVector}\PYG{err}{，}\PYG{n}{QHash}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QSet}\PYG{err}{，}\PYG{n}{在尾部追加元素的时间复杂度均摊下来是}\PYG{+w}{ }\PYG{n}{O}\PYG{p}{(}\PYG{n}{log}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{err}{。}\PYG{n}{但如果在插入元素之前以计划插入的元素个数}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{n}{为参数调用}\PYG{+w}{ }\PYG{n}{QVector}\PYG{o}{::}\PYG{n}{reserve}\PYG{p}{(),}\PYG{+w}{ }\PYG{n}{QHash}\PYG{o}{::}\PYG{n}{reserve}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{或}\PYG{+w}{ }\PYG{n}{QSet}\PYG{o}{::}\PYG{n}{reserve}\PYG{p}{()}\PYG{err}{，}\PYG{n}{复杂度将会降低至}\PYG{+w}{ }\PYG{n}{O}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{err}{。}\PYG{n}{下一节将会针对该问题做更深入的讨论}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{splitLine}

\PYG{err}{\PYGZbs{}}\PYG{n}{section}\PYG{p}{\PYGZob{}}\PYG{n}{增长策略}\PYG{p}{\PYGZcb{}}

\PYG{n}{QVector}\PYG{err}{，}\PYG{n}{QString}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QByteArray}\PYG{+w}{ }\PYG{n}{使用连续内存保存元素}\PYG{err}{；}\PYG{n}{QList}\PYG{+w}{ }\PYG{n}{维护了一个保存所有元素的指针}\PYG{err}{（}\PYG{n}{除非}\PYG{+w}{ }\PYG{n}{T}\PYG{+w}{ }\PYG{n}{本身是一个指针类型或一个指针大小的基本类型}\PYG{err}{，}\PYG{n}{这种情况下数组中保存的的是元素本身的值}\PYG{err}{）}\PYG{n}{的数组}\PYG{err}{，}\PYG{n}{用于提供基于索引的快速访问}\PYG{err}{；}\PYG{n}{QHash}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{内部有一个和大小元素个数成正比的哈希表}\PYG{err}{。}\PYG{n}{为了避免每次在尾部添加元素时重新分配内存}\PYG{err}{，}\PYG{n}{这些类通常会分配比实际需要要多的内存}\PYG{err}{。}

\PYG{n}{考虑下列代码}\PYG{err}{，}\PYG{n}{它用另一个}\PYG{+w}{ }\PYG{n}{QString}\PYG{+w}{ }\PYG{n}{构建出一个新的}\PYG{+w}{ }\PYG{n}{QString}\PYG{err}{：}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{cppcode}\PYG{p}{\PYGZcb{}}
\PYG{n}{QString}\PYG{+w}{ }\PYG{n}{onlyLetters}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{QString}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{in}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{QString}\PYG{+w}{ }\PYG{n}{out}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{in}\PYG{p}{.}\PYG{n}{size}\PYG{p}{();}\PYG{+w}{ }\PYG{o}{++}\PYG{n}{j}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{in}\PYG{p}{[}\PYG{n}{j}\PYG{p}{].}\PYG{n}{isLetter}\PYG{p}{())}
\PYG{+w}{            }\PYG{n}{out}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{n}{in}\PYG{p}{[}\PYG{n}{j}\PYG{p}{];}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{out}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{lstlisting}\PYG{p}{\PYGZcb{}}

\PYG{n}{我们通过每次追加一个字符的方式动态的构建了一个字符串}\PYG{err}{。}\PYG{n}{假设我们追加}\PYG{+w}{ }\PYG{l+m+mi}{15000}\PYG{+w}{ }\PYG{n}{个字符到这个}\PYG{+w}{ }\PYG{n}{QString}\PYG{+w}{ }\PYG{n}{字符串}\PYG{err}{，}\PYG{n}{接下来会在已分配内存耗尽时触发}\PYG{+w}{ }\PYG{n}{QString}\PYG{+w}{ }\PYG{n}{进行}\PYG{+w}{ }\PYG{l+m+mi}{18}\PYG{+w}{ }\PYG{n}{次内存重新分配}\PYG{err}{，}\PYG{n}{分别在已分配量为}\PYG{err}{：}\PYG{l+m+mi}{4}\PYG{err}{，}\PYG{l+m+mi}{8}\PYG{err}{，}\PYG{l+m+mi}{12}\PYG{err}{，}\PYG{l+m+mi}{16}\PYG{err}{，}\PYG{l+m+mi}{20}\PYG{err}{，}\PYG{l+m+mi}{52}\PYG{err}{，}\PYG{l+m+mi}{116}\PYG{err}{，}\PYG{l+m+mi}{244}\PYG{err}{，}\PYG{l+m+mi}{500}\PYG{err}{，}\PYG{l+m+mi}{1012}\PYG{err}{，}\PYG{l+m+mi}{2036}\PYG{err}{，}\PYG{l+m+mi}{4048}\PYG{err}{，}\PYG{l+m+mi}{6132}\PYG{err}{，}\PYG{l+m+mi}{8180}\PYG{err}{，}\PYG{l+m+mi}{10228}\PYG{err}{，}\PYG{l+m+mi}{12276}\PYG{err}{，}\PYG{l+m+mi}{14324}\PYG{err}{，}\PYG{l+m+mi}{16372}\PYG{n}{时}\PYG{err}{。}\PYG{n}{最后}\PYG{err}{，}\PYG{n}{这个}\PYG{+w}{ }\PYG{n}{QString}\PYG{+w}{ }\PYG{n}{占用了}\PYG{+w}{ }\PYG{l+m+mi}{16372}\PYG{+w}{ }\PYG{n}{个}\PYG{+w}{ }\PYG{n}{Unicode}\PYG{+w}{ }\PYG{n}{字符的空间}\PYG{err}{，}\PYG{n}{其中}\PYG{+w}{ }\PYG{l+m+mi}{15000}\PYG{+w}{ }\PYG{n}{个被实际使用了}\PYG{err}{。}

\PYG{n}{上面的数字可能有些奇怪}\PYG{err}{，}\PYG{n}{这里是分配的指导原则}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{compactitem}\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{item}\PYG{+w}{ }\PYG{n}{QString}\PYG{+w}{ }\PYG{n}{每次分配}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{+w}{ }\PYG{n}{个字符指导达到}\PYG{+w}{ }\PYG{l+m+mi}{20}\PYG{+w}{ }\PYG{n}{个字符}\PYG{err}{。}
\PYG{err}{\PYGZbs{}}\PYG{n}{item}\PYG{+w}{ }\PYG{n}{从}\PYG{+w}{ }\PYG{l+m+mi}{20}\PYG{+w}{ }\PYG{n}{到}\PYG{+w}{ }\PYG{l+m+mi}{4084}\PYG{+w}{ }\PYG{n}{个字符}\PYG{err}{，}\PYG{n}{每次将当前的大小翻倍}\PYG{err}{。}\PYG{n}{更准确的说}\PYG{err}{，}\PYG{n}{是翻倍后再减去}\PYG{+w}{ }\PYG{l+m+mi}{12}\PYG{err}{。（}\PYG{n}{一些内存分配器在分配刚好两倍的内存时性能较差}\PYG{err}{，}\PYG{n}{因为它们需要使用每块内存块中的一些字节用于登记}\PYG{err}{。}
\PYG{err}{\PYGZbs{}}\PYG{n}{item}\PYG{+w}{ }\PYG{n}{从}\PYG{+w}{ }\PYG{l+m+mi}{4084}\PYG{+w}{ }\PYG{n}{开始}\PYG{err}{，}\PYG{n}{每次分配将会在原来的基础上增加}\PYG{+w}{ }\PYG{l+m+mi}{2048}\PYG{+w}{ }\PYG{n}{个字符大小}\PYG{err}{（}\PYG{l+m+mi}{4096}\PYG{+w}{ }\PYG{n}{字节}\PYG{err}{）。}\PYG{n}{这么做的意义是现代操作系统在重新分配内存时并不会复制全部的数据}\PYG{err}{，}\PYG{n}{而仅仅是简单地将物理内存页重新排序}\PYG{p}{,}\PYG{n}{只有第一页和最后一页的数据需要复制}\PYG{err}{。}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{compactitem}\PYG{p}{\PYGZcb{}}

\PYG{n}{QByteArray}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QList}\PYG{+w}{ }\PYG{n}{使用和}\PYG{+w}{ }\PYG{n}{QString}\PYG{+w}{ }\PYG{n}{差不多的增长算法}\PYG{err}{。}

\PYG{n}{当数据类型支持通过}\PYG{+w}{ }\PYG{n}{memcpy}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{在内存中进行移动时}\PYG{err}{（}\PYG{n}{包括基本}\PYG{+w}{ }\PYG{n}{C}\PYG{o}{++}\PYG{+w}{ }\PYG{n}{类型}\PYG{err}{，}\PYG{n}{指针类型和}\PYG{+w}{ }\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{的隐式共享类}\PYG{err}{），}\PYG{n}{QVector}\PYG{+w}{ }\PYG{n}{也使用相同的算法}\PYG{err}{。}\PYG{n}{但在数据类型只支持通过复制构造函数和析构函数进行移动时则使用不同的算法}\PYG{err}{。}\PYG{n}{在这种情况下}\PYG{err}{，}\PYG{n}{重新分配的开销会大的多}\PYG{err}{，}\PYG{n}{因此}\PYG{+w}{ }\PYG{n}{QVector}\PYG{+w}{ }\PYG{n}{将总是会在空间耗尽时直接申请两倍的内存}\PYG{err}{，}\PYG{n}{以减少重新分配的次数}\PYG{err}{。}

\PYG{n}{QHash}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{则是完全不同}\PYG{err}{。}\PYG{n}{QHash}\PYG{+w}{ }\PYG{n}{内部的哈希表每次增长两倍}\PYG{err}{，}\PYG{n}{每次增长时}\PYG{err}{，}\PYG{n}{保存的元素将会重新分配到一个通过}\PYG{+w}{ }\PYG{n}{qHash}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{+w}{ }\PYG{err}{\PYGZbs{}}\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{n}{QHash}\PYG{o}{::}\PYG{n}{capacity}\PYG{p}{()}\PYG{err}{（}\PYG{n}{簇序号}\PYG{err}{）}\PYG{n}{计算出来的新的簇中}\PYG{err}{。}\PYG{n}{此说明同样适用于}\PYG{+w}{ }\PYG{n}{QSet}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QCache}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{err}{。}

\PYG{n}{对于大部分的应用}\PYG{err}{，}\PYG{n}{Qt}\PYG{+w}{ }\PYG{n}{提供的增长策略完全可以满足需要}\PYG{err}{。}\PYG{n}{如果你需要进行自}
\PYG{n}{定义调整}\PYG{err}{，}\PYG{n}{QVector}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QHash}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QSet}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{QString}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QByteArray}\PYG{+w}{ }\PYG{n}{提供了一}
\PYG{n}{个提供了三个方法用于检查和指定保存元素使用的内存量}\PYG{err}{。}

\PYG{err}{\PYGZbs{}}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{compactitem}\PYG{p}{\PYGZcb{}}
\PYG{err}{\PYGZbs{}}\PYG{n}{item}\PYG{+w}{ }\PYG{n}{capacity}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{用于返回已分配内存的元素个数}\PYG{err}{（}\PYG{n}{对于QHash}\PYG{+w}{ }\PYG{n}{和}\PYG{+w}{ }\PYG{n}{QSet}\PYG{err}{，}\PYG{n}{返回的是哈希表的簇的个数}\PYG{err}{）。}
\PYG{err}{\PYGZbs{}}\PYG{n}{item}\PYG{+w}{ }\PYG{n}{reserve}\PYG{p}{(}\PYG{n}{size}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{用于显式的预分配}\PYG{+w}{ }\PYG{n}{size}\PYG{+w}{ }\PYG{n}{个元素大小的内存}\PYG{err}{。}
\PYG{err}{\PYGZbs{}}\PYG{n}{item}\PYG{+w}{ }\PYG{n}{squeeze}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{用于释放所有没有用来保存元素的内存}\PYG{err}{。}
\PYG{err}{\PYGZbs{}}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{compactitem}\PYG{p}{\PYGZcb{}}

\PYG{n}{如果预先知道容器要保存元素的大概数量}\PYG{err}{，}\PYG{n}{可以提前调用}\PYG{+w}{ }\PYG{n}{reserve}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{方法分配}
\PYG{n}{内存}\PYG{err}{，}\PYG{n}{最后在填充完容器后}\PYG{err}{，}\PYG{n}{再调用}\PYG{+w}{ }\PYG{n}{squeeze}\PYG{p}{()}\PYG{+w}{ }\PYG{n}{来释放多余的预分配内存}\PYG{err}{。}

\PYG{o}{\PYGZpc{}\PYGZpc{}\PYGZpc{}}\PYG{+w}{ }\PYG{n}{Local}\PYG{+w}{ }\PYG{n}{Variables}\PYG{o}{:}
\PYG{o}{\PYGZpc{}\PYGZpc{}\PYGZpc{}}\PYG{+w}{ }\PYG{n}{mode}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{latex}
\PYG{o}{\PYGZpc{}\PYGZpc{}\PYGZpc{}}\PYG{+w}{ }\PYG{n}{TeX}\PYG{o}{\PYGZhy{}}\PYG{n}{master}\PYG{o}{:}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}../../master\PYGZdq{}}
\PYG{o}{\PYGZpc{}\PYGZpc{}\PYGZpc{}}\PYG{+w}{ }\PYG{n}{End}\PYG{o}{:}

\end{Verbatim}
