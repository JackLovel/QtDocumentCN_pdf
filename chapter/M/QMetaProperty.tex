\chapter{QMetaProperty}

QMetaProperty 类提供了对应一条属性的元数据。更多内容...

\begin{tabular}{|r|l|}
	\hline
	属性 & 方法 \\
	\hline
<<<<<<< HEAD
    头文件 	\hl{\#include <QMetaProperty>} \\
    \hline
    qmake: \hl{QT += core}    \\
=======
    头文件  &	\hl{\#include <QMetaProperty>} \\
    \hline
    qmake: & \hl{QT += core}    \\
>>>>>>> dev
	\hline
\end{tabular}

\section{公共成员函数}

\begin{longtable}{|r|m{28em}|}   
\hline
返回类型 	& 函数 \\
\hline
QMetaEnum &	enumerator() const \\
\hline 
bool &	hasNotifySignal() const \\ 
\hline
bool &	isConstant() const \\ 
\hline
<<<<<<< HEAD
bool &	isDesignable(const QObject *object = nullptr) const \\
=======
bool &	isDesignable(const QObject \emph{*object} = nullptr) const \\
>>>>>>> dev
\hline
bool &	isEnumType() const \\
\hline
bool 	&isFinal() const \\ 
\hline
bool 	&isFlagType() const \\ 
\hline
bool &	isReadable() const \\ 
\hline
bool &	isRequired() const\\
\hline
bool &	isResettable() const\\
\hline
<<<<<<< HEAD
bool &	isScriptable(const QObject *object = nullptr) const\\
\hline
bool 	&isStored(const QObject *object = nullptr) const\\
\hline
bool 	&isUser(const QObject *object = nullptr) const\\
=======
bool &	isScriptable(const QObject \emph{*object} = nullptr) const\\
\hline
bool 	&isStored(const QObject \emph{*object} = nullptr) const\\
\hline
bool 	&isUser(const QObject \emph{*object} = nullptr) const\\
>>>>>>> dev
\hline
bool &	isValid() const\\
\hline
bool 	&isWritable() const\\
\hline
const char * &	name() const\\
\hline
QMetaMethod &	notifySignal() const\\
\hline
int 	& notifySignalIndex() const\\
\hline
int  &	propertyIndex() const\\
\hline
<<<<<<< HEAD
QVariant &	read(const QObject *object) const \\
\hline
QVariant 	&readOnGadget(const void *gadget) const \\
=======
QVariant &	read(const QObject \emph{*object}) const \\
\hline
QVariant 	&readOnGadget(const void \emph{*gadget}) const \\
>>>>>>> dev
\hline
int 	&relativePropertyIndex() const\\
\hline
bool &	reset(QObject \emph{*object}) const\\
\hline
bool 	&resetOnGadget(void \emph{*gadget}) const \\
\hline
int 	&revision() const\\
\hline
QVariant::Type &	type() const \\
\hline
const char * &	typeName() const \\ 
\hline
int 	& userType() const \\ 
\hline
<<<<<<< HEAD
bool &	write(QObject *object, const QVariant \&value) const \\ 
\hline
bool 	&writeOnGadget(void *gadget, const QVariant \&value) const \\ 
=======
bool &	write(QObject \emph{*object}, const QVariant \emph{\&value}) const \\ 
\hline
bool 	&writeOnGadget(void \emph{*gadget}, const QVariant \emph{\&value}) const \\ 
>>>>>>> dev
\hline
\end{longtable}


<<<<<<< HEAD

\section{静态公共成员}

\begin{longtable}{|l|m{28em}|}
\hline
返回类型 &	函数 \\ 
\hline
bool	&checkConnectArgs(const char *signal, const char *method) \\
\hline
bool	&checkConnectArgs(const QMetaMethod \&signal, const QMetaMethod \&method) \\
\hline
void	&connectSlotsByName(QObject *object) \\
\hline
bool	&invokeMethod(QObject *obj, const char *member, Qt::ConnectionType type, QGenericReturnArgument ret, QGenericArgument val0 = QGenericArgument(nullptr), QGenericArgument val1 = QGenericArgument(), QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument())\\
\hline
bool	&invokeMethod(QObject *obj, const char *member, QGenericReturnArgument ret, QGenericArgument val0 = QGenericArgument(0), QGenericArgument val1 = QGenericArgument(), QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument())\\
\hline
bool	&invokeMethod(QObject *obj, const char *member, Qt::ConnectionType type, QGenericArgument val0 = QGenericArgument(0), QGenericArgument val1 = QGenericArgument(), QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument())\\
\hline
bool	&invokeMethod(QObject *obj, const char *member, QGenericArgument val0 = QGenericArgument(0), QGenericArgument val1 = QGenericArgument(), QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument())\\
\hline
bool	&invokeMethod(QObject *context, Functor function, Qt::ConnectionType type = Qt::AutoConnection, FunctorReturnType *ret = nullptr) \\
\hline
bool	&invokeMethod(QObject *context, Functor function, FunctorReturnType *ret) \\
\hline
QByteArray&	normalizedSignature(const char *method) \\
\hline
QByteArray&	normalizedType(const char *type)\\
\hline
\end{longtable}

\section{宏定义}

\begin{tabular}{|l|l|}
\hline
返回类型	& 宏定义 \\
\hline
QGenericArgument	& Q\_ARG(Type, const Type \&value) \\
\hline
QGenericReturnArgument&	Q\_RETURN\_ARG(Type, Type \&value) \\
\hline
\end{tabular}



\section{详细描述}

Qt 的元对象系统负责信号槽跨对象通信机制、运行时类型信息和 Qt 的属性系统。
应用中的每个 QObject 子类都有一个唯一的 QMetaObject 实例（译者注：与类一一对应，即同一个 QObject 子类的任意对象，都使用同一个 QMetaObject），其中保存了这个 QObject 子类的所有元信息，可以通过 QObject::metaObject() 获取。

QMetaObject 在应用编写中通常不需要，但在进行元编程时会非常有用，例如脚本引擎或者用户界面生成器。

最常用的成员函数有：

\begin{compactitem}
\item className() 返回类的名称。
\item superClass() 返回父类对应的元对象。
\item method() 和 methodCount() 提供关于一个类的元方法（信号、槽和其它可动态调用的成员方法）。
\item enumerator() 和 enumeratorCount() 提供一个类的枚举类型的信息。
\item propertyCount() 和 property() 提供一个类的属性的信息。
\item constructor() 和 constructorCount() 提供一个类的元构造函数的信息。
\end{compactitem}


索引函数 indexOfConstructor()、indexOfMethod()、indexOfEnumerator() 和 indexOfProperty() 将构造函数、成员函数、枚举类型和属性的名称映射为索引。例如，当连接信号槽时，Qt 内部使用 indexOfMethod() 进行检索。

类可以拥有一系列 名称—数值 格式的附加信息，保存在 QMetaClassInfo 对象中。信息条目数量可通过 classInfoCount()查询， classInfo()返回单条信息，也可通过 indexOfClassInfo() 检索信息条目。

\begin{notice}
元对象系统的操作通常是线程安全的，比如元对象是在编译期生成的静态只读实例。
然而，如果元对象在被程序动态修改了（如通过 QQmlPropertyMap），应用需要显示地同步对相关对象的访问。
\end{notice}

\begin{notice}[另请参阅]
QMetaClassInfo、QMetaEnum、QMetaMethod、QMetaProperty、QMetaType 和 Meta-Object System。
\end{notice}

\section{成员函数文档}

[static] bool QMetaObject::checkConnectArgs(const char \emph{*signal}, const char \emph{*method})

如果 signal 和 method 的参数能够匹配则返回 true，否则返回 false。

signal 和 method 都被假设是已经规范化的。

\begin{notice}[另请参阅]
normalizedSignature()。
\end{notice}

[static] bool QMetaObject::checkConnectArgs(const QMetaMethod \emph{\&signal}, const QMetaMethod \emph{\&method})

这是一个重载函数。

如果 signal 和 method 的参数能够匹配则返回 true，否则返回 false。

本函数在 Qt 5.0 中被引入。

QMetaClassInfo QMetaObject::classInfo(int \emph{index}) const

返回对应 index 的类型信息的元数据对象。

范例：

\begin{lstlisting}[language=C++]
class MyClass : public QObject
 {
     Q_OBJECT
     Q_CLASSINFO("author", "Sabrina Schweinsteiger")
     Q_CLASSINFO("url", "http://doc.moosesoft.co.uk/1.0/")

 public:
     ...
 };
\end{lstlisting}


%%%%%%%%%%%%%%%%

\begin{notice}[另请参阅]
classInfoCount()、classInfoOffset() 和 indexOfClassInfo()。
\end{notice}

int QMetaObject::classInfoCount() const

返回该类信息条目数量。

\begin{notice}[另请参阅]
classInfo()、classInfoOffset() 和 indexOfClassInfo()。
\end{notice}

int QMetaObject::classInfoOffset() const

返回类信息在该类中的偏移量，即第一条类信息的编号。

若该类没有包含类信息的父类，则偏移量为 0，否则偏移量是所有父类的类信息数量的总和。

\begin{notice}[另请参阅]
classInfo()、classInfoCount() 和 indexOfClassInfo()。
\end{notice}

const char *QMetaObject::className() const

返回该类的名称。

\begin{notice}[另请参阅]
superClass()。
\end{notice}

[static] void QMetaObject::connectSlotsByName(QObject \emph{*object})

递归检索 \emph{object} 和所有子对象，将它们的信号连接至 object 中匹配的槽，匹配格式如下：

\begin{lstlisting}
void on_<对象名>_<信号名>(<信号参数>);
\end{lstlisting}

假设有一个对象名 为 button1 的 QPushButton 类型的子对象，则捕获它的 clicked() 信号的槽应为：

\begin{lstlisting}
void on_button1_clicked();
\end{lstlisting}

若 object 对象自身的名字已设置，则它自己的信号也会被连接至对应的槽。

\begin{notice}[另请参阅]
QObject::setObjectName().
\end{notice}

%%%%%%%%%%%
QMetaMethod QMetaObject::constructor(int \emph{index}) const

返回指定 \emph{index} 的构造函数的元数据。

该函数在 Qt 4.5 中被引入。

\begin{notice}[另请参阅]
constructorCount() 和 newInstance()。
\end{notice}

int QMetaObject::constructorCount() const

返回此类的构造函数个数。

该函数在 Qt 4.5 中被引入。

\begin{notice}[另请参阅]
constructor() 和 indexOfConstructor()。
\end{notice}

QMetaEnum QMetaObject::enumerator(int \emph{index}) const

返回指定 \emph{index} 的枚举类型的元数据。

\begin{notice}[另请参阅]
enumeratorCount()、enumeratorOffset() 和 indexOfEnumerator()。
\end{notice}

int QMetaObject::enumeratorCount() const

返回该类的枚举类型的个数。

\begin{notice}[另请参阅]
enumerator()、enumeratorOffset() 和 indexOfEnumerator()。
\end{notice}
	
int QMetaObject::enumeratorOffset() const

返回该类的枚举类型偏移量，即首个枚举变量的编号。

若该类没有包含枚举类型的父类，则偏移量为 0，否则偏移量是所有父类的枚举类型数量的总和。

\begin{notice}[另请参阅]
enumerator()、enumeratorCount() 和 indexOfEnumerator()。
\end{notice}

int QMetaObject::indexOfClassInfo(const char \emph{*name}) const

查找名为 \emph{name} 的类型信息条目并返回其编号，未找到则返回-1。

\begin{notice}[另请参阅]
classInfo()、classInfoCount() 和 classInfoOffset()。
\end{notice}

int QMetaObject::indexOfConstructor(const char \emph{*constructor}) const

查找名为 \emph{constructor} 的构造函数并返回其编号，未找到则返回-1。

\begin{notice}
constructor 需要为规范化的格式，如 normalizedSignature() 的返回值。
\end{notice}

该函数在 Qt 4.5 中被引入。

\begin{notice}[另请参阅]
constructor()、constructorCount() 和 normalizedSignature()。
\end{notice}

int QMetaObject::indexOfEnumerator(const char \emph{*name}) const

查找名为 \emph{name} 的枚举类型并返回其编号，未找到则返回-1。

\begin{notice}
enumerator(), enumeratorCount() 和 enumeratorOffset().
\end{notice}

int QMetaObject::indexOfMethod(const char \emph{*method}) const

查找名为 \emph{method} 的方法并返回其编号，未找到则返回-1。

\begin{notice}
method 需要为规范化的格式，如 normalizedSignature() 的返回值。
\end{notice}

\begin{notice}[另请参阅]
method()、methodCount()、methodOffset() 和 normalizedSignature()。
\end{notice}

int QMetaObject::indexOfProperty(const char \emph{*name}) const

查找名为 name 的属性并返回其编号，未找到则返回-1。

\begin{notice}[另请参阅]
property()、propertyCount() 和 propertyOffset()。	
\end{notice}

int QMetaObject::indexOfSignal(const char \emph{*signal}) const

查找名为 name 的信号并返回其编号，未找到则返回-1。

此方法与 indexOfMethod() 相似，区别是若该方法存在但并非信号函数，则会返回 -1。

\begin{notice}
signal 需要为规范化的格式，如 normalizedSignature() 的返回值。	
\end{notice}

\begin{notice}[另请参阅]
indexOfMethod()、normalizedSignature(), method()、methodCount() 和 methodOffset()。
\end{notice}

int QMetaObject::indexOfSlot(const char \emph{*slot}) const

查找名为 name 的槽并返回其编号，未找到则返回-1。

此方法与 indexOfMethod() 相似，区别是若该方法存在但并非槽函数，则会返回 -1。

\begin{notice}[另请参阅]
indexOfMethod()、method()、methodCount() 和 methodOffset()。
\end{notice}


bool QMetaObject::inherits(const QMetaObject \emph{*metaObject}) const

若该 QMetaObject 继承自 \emph{metaObject} 描述的类型，则返回 true，否则返回 false。

一个类型被认为是继承自它自己的。

该函数在 Qt 5.7 中被引入。

%%%%%%
[static] bool QMetaObject::invokeMethod(QObject *obj, const char *member, 
 Qt::ConnectionType type, QGenericReturnArgument ret, 
 QGenericArgument val0 = QGenericArgument(nullptr), QGenericArgument val1 = QGenericArgument(), 
 QGenericArgument val2 = QGenericArgument(),QGenericArgument val3 = QGenericArgument(), 
 QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), 
 QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), 
 QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument())

通过 obj 对象动态调用它的 member 方法（或者信号和槽），若调用成功则返回 true，若该对象没有此方法或参数不匹配则返回 false。

该调用可以是同步或异步的，由 type 决定：

\begin{compactitem}
\item 若 type 是 Qt::DirectConnection，则该方法会被立即执行。
\item 若 type 是 Qt::QueuedConnection，则会发送一个 QEvent ，该方法会在应用进入该对象所属线程的主事件循环后执行。
\item 若 type 是 Qt::BlockingQueuedConnection，则该方法会通过与 Qt::QueuedConnection 相同的方式执行，
	此外当前线程会被阻塞，直到该事件被响应。使用此方法在相同线程的对象间通信会导致死锁。
\item 若 type 是 Qt::AutoConnection，当 obj 与调用者处于相同线程中时，该方法会被同步执行，否则会被异步执行。
\end{compactitem}

member 函数的返回值会被存放在 ret 中。若调用方式是异步，则返回值无法被获取。最多可以传递十个参数 (val0, val1, val2, val3, val4, val5, val6, val7, val8 和 val9) 至 member 函数。

QGenericArgument 和 QGenericReturnArgument 是内部的辅助类。为了动态调用信号槽，您需要将参数通过 Q\_ARG() 和 Q\_RETURN\_ARG() 宏进行封装。
Q\_ARG() 接受一个类型名称和一个该类型的不可变引用；
Q\_RETURN\_ARG() 接受一个类型名称和一个该类型的可变引用。

您只需要将信号槽的名称传递至本函数，无需传递完整的签名。

例如，异步调用某个 QThread 对象的 quit() 槽需要的代码如下：

\begin{lstlisting}[language=C++]
QMetaObject::invokeMethod(thread, "quit",
                           Qt::QueuedConnection);
\end{lstlisting}

当异步调用方法时，传递的参数必须被 Qt 的元对象系统所知悉，因为 Qt 需要在后台事件中拷贝并保存它们。
如果您使用队列连接时遇到下述错误信息：

\begin{lstlisting}
QMetaObject::invokeMethod: Unable to handle unregistered datatype 'MyType'
\end{lstlisting}

则在调用 invokeMethod() 之前通过 qRegisterMetaType() 来注册该数据类型。

若想通过 obj 对象同步调用 compute(QString, int, double) 槽，则代码如下：

\begin{lstlisting}[language=C++]
 QString retVal;
 QMetaObject::invokeMethod(obj, "compute", Qt::DirectConnection,
                           Q_RETURN_ARG(QString, retVal),
                           Q_ARG(QString, "sqrt"),
                           Q_ARG(int, 42),
                           Q_ARG(double, 9.7));
\end{lstlisting}

若 compute 槽通过特定顺序没有完整获取到一个 QString、一个 int 和一个 double，则此调用会失败。

\begin{notice}
此方法是线程安全的。
\end{notice}

\begin{notice}[另请参阅]
Q\_ARG()、Q\_RETURN\_ARG()、qRegisterMetaType() 和 QMetaMethod::invoke()。
\end{notice}

%%%%%%%%%%%

[static] bool QMetaObject::invokeMethod(QObject \emph{*obj}, const char \emph{*member}, QGenericReturnArgument \emph{ret}, 
QGenericArgument val0 = QGenericArgument(0), QGenericArgument val1 = QGenericArgument(), 
QGenericArgument val2 = QGenericArgument(), 
QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), 
QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), 
QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), 
QGenericArgument val9 = QGenericArgument())

此函数是 invokeMethod() 的重载。

此重载始终通过 Qt::AutoConnection 调用对应方法。

\begin{notice}
此方法是线程安全的。
\end{notice}

[static] bool QMetaObject::invokeMethod(QObject *obj, const char *member, Qt::ConnectionType type, QGenericArgument val0 = QGenericArgument(0), QGenericArgument val1 = QGenericArgument(), QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument())

此函数是 invokeMethod() 的重载。

此重载用于不关心对返回值的场合。


\begin{notice}
此方法是线程安全的。
\end{notice}


[static] bool QMetaObject::invokeMethod(QObject \emph{*obj}, const char \emph{*member}, 
 QGenericArgument val0 = QGenericArgument(0), QGenericArgument val1 = QGenericArgument(),
  QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(),
   QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), 
   QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), 
   QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument())

此函数是 invokeMethod() 的重载。

此重载通过 Qt::AutoConnection 调用对应方法，并忽略返回值。

\begin{notice}
此方法是线程安全的。
\end{notice}

[static] template <typename Functor, typename FunctorReturnType> bool QMetaObject::invokeMethod(QObject \emph{*context}, Functor \emph{function}, Qt::ConnectionType \emph{type} = Qt::AutoConnection, FunctorReturnType \emph{*ret} = nullptr)

此函数是 invokeMethod() 的重载。

通过 type 方式在 \emph{context} 所属的事件循环中动态调用 \emph{function}。\emph{function} 可以是一个仿函数或成员函数指针。
若该函数可被动态调用则返回 true，当该函数不存在或参数不匹配时返回 false。函数的返回值将被保存至 \emph{ret} 中。

\begin{notice}
此方法是线程安全的。
\end{notice}

该函数在 Qt 5.10 中被引入。

[static] template <typename Functor, typename FunctorReturnType> bool QMetaObject::invokeMethod(QObject \emph{*context}, Functor \emph{function}, FunctorReturnType \emph{*ret})

此函数是 invokeMethod() 的重载。

通过 Qt::AutoConnection 方式动态调用 \emph{function}。\emph{function} 可以是一个仿函数或成员函数指针。
若该函数可被动态调用则返回 true，当该函数不存在或参数不匹配时返回 false。函数的返回值将被保存至 \emph{ret} 中。


\begin{notice}
此方法是线程安全的。
\end{notice}


该函数在 Qt 5.10 中被引入。

QMetaMethod QMetaObject::method(int \emph{index}) const

返回指定 \emph{index} 的方法的元数据。

\begin{notice}[另请参阅]
methodCount(), methodOffset() 和 indexOfMethod().
\end{notice}

int QMetaObject::methodCount() const

返回该类中方法的数量，包括所有基类的方法个数。除了常规成员函数外，也包含信号函数和槽函数。

使用下述代码来将所给类的所有方法签名存储至 QStringList：

\begin{lstlisting}[language=C++]
 const QMetaObject* metaObject = obj->metaObject();
 QStringList methods;
 for(int i = metaObject->methodOffset(); i < metaObject->methodCount(); ++i)
     methods << QString::fromLatin1(metaObject->method(i).methodSignature());
\end{lstlisting}

\begin{notice}[另请参阅]
method()、methodOffset() 和 indexOfMethod()。
\end{notice}

int QMetaObject::methodOffset() const

返回类方法在该类中的偏移量，即第一个类方法的编号。

该偏移量是所有父类的方法数总和（因此总为正数，因为 QObject 有 deleteLater() 槽和 destroyed() 信号）。

\begin{notice}[另请参阅]
method()、methodCount() 和 indexOfMethod()。
\end{notice}

QObject *QMetaObject::newInstance(QGenericArgument \emph{val0} = QGenericArgument(nullptr), QGenericArgument \emph{val1} = QGenericArgument(), 
    QGenericArgument \emph{val2} = QGenericArgument(), QGenericArgument \emph{val3} = QGenericArgument(), 
    QGenericArgument \emph{val4} = QGenericArgument(), QGenericArgument \emph{val5} = QGenericArgument(), 
    QGenericArgument \emph{val6} = QGenericArgument(), QGenericArgument \emph{val7} = QGenericArgument(), 
    QGenericArgument \emph{val8} = QGenericArgument(), QGenericArgument \emph{val9} = QGenericArgument()) const

构造一个此类的新实例。您可以传递最多十个参数 (val0, val1, val2, val3, val4, val5, val6, val7, val8 和 val9) 至构造函数。返回构造的新对象，若没有合适的构造函数则返回 nullptr。

\begin{notice}
只有通过 Q\_INVOKABLE 修饰符声明的构造函数才能在元对象系统中使用。
\end{notice}

该函数在 Qt 4.5 中被引入。

\begin{notice}[另请参阅]
Q\_ARG() 和 constructor()。
\end{notice}

[static] QByteArray QMetaObject::normalizedSignature(const char \emph{*method})

将给予的 \emph{method} 进行规范化。

Qt 使用规范化的签名来来判断两个给定的信号和槽是否匹配。
规范化操作会将空格减到最少，将 const 适当前移，移除值类型的 const，并将不可变引用替换为值类型。

\begin{notice}[另请参阅]
checkConnectArgs() 和 normalizedType()。
\end{notice}

[static] QByteArray QMetaObject::normalizedType(const char \emph{*type})

将 \emph{type} 规范化。

请参阅 QMetaObject::normalizedSignature() 中关于 Qt 如何进行规范化的描述。

范例:

\begin{lstlisting}[language=C++]
 QByteArray normType = QMetaObject::normalizedType(" int    const  *");
 // 规范化的类型将为 "const int*"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%

该函数在 Qt 4.2 中被引入。

\begin{notice}[另请参阅]
normalizedSignature()。
\end{notice}

QMetaProperty QMetaObject::property(int \emph{index}) const

返回指定 \emph{index} 的属性的元数据。
若该属性不存在，则返回空的 QMetaProperty 对象。

\begin{notice}[另请参阅]
propertyCount()、propertyOffset() 和 indexOfProperty()。
\end{notice}

int QMetaObject::propertyCount() const

返回该类中属性的类型，包括所有基类的属性个数。

使用如下代码来将给定类的所有属性名称保存至 QStringList: 

\begin{lstlisting}[language=C++]
 const QMetaObject* metaObject = obj->metaObject();
 QStringList properties;
 for(int i = metaObject->propertyOffset(); i < metaObject->propertyCount(); ++i)
     properties << QString::fromLatin1(metaObject->property(i).name());
\end{lstlisting}

\begin{notice}[另请参阅]
property()、propertyOffset() 和 indexOfProperty()。
\end{notice}

int QMetaObject::propertyOffset() const

返回类属性在该类中的偏移量，即第一条类属性的编号。

该偏移量包含所有父类的类属性数量总和（因此总为正数，因为 QObject 有 name() 属性）。

\begin{notice}[另请参阅]
property()、propertyCount() 和 indexOfProperty()。
\end{notice}

const QMetaObject *QMetaObject::superClass() const

返回父类的元对象，若不存在则返回 \hl{nullptr}。

\begin{notice}[另请参阅]
className()。
\end{notice}

QMetaProperty QMetaObject::userProperty() const

返回 \hl{USER} 标志位为 \hl{true} 的元属性。

该函数在 Qt 4.2 中被引入。

\begin{notice}[另请参阅]
QMetaProperty::isUser()。
\end{notice}

\section{宏定义文档}

QGenericArgument Q\_ARG(Type, const Type \emph{\&value})

该宏接受一个 \hl{type} 和一个该类型的 \hl{value} 参数，

返回一个用于传递至 QMetaObject::invokeMethod() 的 QGenericArgument 对象。

\begin{notice}[另请参阅]
Q\_RETURN\_ARG()。
\end{notice} 

QGenericReturnArgument Q\_RETURN\_ARG(\emph{Type}, Type \emph{\&value})

该宏接受一个 \hl{Type} 和一个该类型的可变引用 \hl{value} 参数，

返回一个用于传递至 QMetaObject::invokeMethod() 的包含该类型的 QGenericReturnArgument 对象。

\begin{notice}[另请参阅]
Q\_ARG()。
\end{notice} 
=======
\section{详细描述}

属性元数据可通过对象的元对象获取。详见 QMetaObject::property() 和 QMetaObject::propertyCount()。

\subsection{属性元数据}

属性具有 name() 和 type()，并且有不同的成员来表示其外在表现: isReadable()、isWritable()、isDesignable()、
isScriptable()、revision() 和 isStored()。

若该属性是枚举变量，则 isEnumType() 返回 true；
若该属性是枚举，同时也是标志位（即可通过或运算合并多个值），
则 isEnumType() 和 isFlagType() 都返回 true。这些类型的枚举值可以通过 enumerator() 查询。

属性的值通过 read()、write() 和 reset()来获取或设置，也可以通过 QObject 的 get 和 set 函数来操作，
详见 QObject::setProperty() 和 QObject::property()。

\subsection{拷贝与赋值}

QMetaProperty 对象可以通过传值方式拷贝，与此同时，每份副本内部都会指向相同的属性元数据。

\begin{seeAlso}
QMetaObject，QMetaEnum，QMetaMethod 和 Qt 属性系统。
\end{seeAlso}

\section{成员函数文档}

QMetaEnum QMetaProperty::enumerator() const

若该属性是枚举类型，则返回对应的枚举器，否则返回未定义值。

\begin{seeAlso}
isEnumType() 和 isFlagType()。
\end{seeAlso}

bool QMetaProperty::hasNotifySignal() const

若该属性有对应的通知信号则返回 true，否则返回 false。

\begin{seeAlso}
notifySignal()。
\end{seeAlso}

bool QMetaProperty::isConstant() const

若该属性在 Q\_PROPERTY() 中被标记为 CONSTANT 则返回 true，否则返回 false。

本函数在 Qt 4.6 中被引入。

bool QMetaProperty::isDesignable(const QObject \emph{*object} = nullptr) const

若该属性可被设计师(Qt Designer)编辑则返回 true，否则返回 false。

若 object 未被指定，则当 Q\_PROPERTY() 的 DESIGNABLE 标记被指定为 false时，此函数返回 false ；其它情况下返回 true（若该标记被指定为 true，或指定为某个函数，或指定为表达式）。

\begin{seeAlso}
isScriptable() 和 isStored()。
\end{seeAlso}

bool QMetaProperty::isEnumType() const

若该属性是枚举类型则返回 true，否则返回 false。

\begin{seeAlso}
enumerator() 和 isFlagType()。
\end{seeAlso}

bool QMetaProperty::isFinal() const

若该属性在 Q\_PROPERTY() 中被标记为 FINAL 则返回 true，否则返回 false。

本函数在 Qt 4.6 中被引入。

bool QMetaProperty::isFlagType() const

若该属性是标志位则返回 true，否则返回 false。

标志位可以通过或运算合并多个值。标志位通常也是枚举类型。

\begin{seeAlso}
isEnumType()，enumerator() 和 QMetaEnum::isFlag()。
\end{seeAlso}

bool QMetaProperty::isReadable() const

若该属性可被读取则返回 true，否则返回 false。

\begin{seeAlso}
isWritable()，read() 和 isValid()。
\end{seeAlso}

bool QMetaProperty::isRequired() const

若该属性在 Q\_PROPERTY() 中被标记为 REQUIRED 则返回 true，否则返回 false。

本函数在 Qt 5.15 中被引入。

bool QMetaProperty::isResettable() const

若该属性可被重置为默认值则返回 true，否则返回 false。

\begin{seeAlso}
reset()。
\end{seeAlso}

bool QMetaProperty::isScriptable(const QObject \emph{*object} = nullptr) const

若该属性可被脚本化则返回 true，否则返回 false。

若 object 未被指定，则当 Q\_PROPERTY() 的 SCRIPTABLE 标记被指定为 false时，此函数返回 false ；
其它情况下返回 true（若该标记被指定为 true，或指定为某个函数，或指定为表达式）。

\begin{seeAlso}
isDesignable() 和 isStored()。
\end{seeAlso}

bool QMetaProperty::isStored(const QObject *object = nullptr) const

若该属性可存储则返回 true，否则返回 false。

若 object 未被指定，则当 Q\_PROPERTY() 的 STORED 标记被指定为 false时，此函数返回 false ；其它情况下返回 true（若该标记被指定为 true，或指定为某个函数，或指定为表达式）。

\begin{seeAlso}
isDesignable() 和 isScriptable()。
\end{seeAlso}

bool QMetaProperty::isUser(const QObject *object = nullptr) const

若该属性被设计为 USER 性质则返回 true，即可以在 object 中被用户编辑，或在某些方面很重要；其它情况下返回 false。例如，QLineEdit 的 text 属性是 USER 可编辑的。

若 object 是 nullptr，则当 Q\_PROPERTY() 的 STORED 标记被指定为 false时，此函数返回 false ；
其它情况下返回 true。

\begin{seeAlso}
QMetaObject::userProperty()，isDesignable() 和 isScriptable()。
\end{seeAlso}

bool QMetaProperty::isValid() const

若该属性是有效的（可读）则返回 true，否则返回 false。

\begin{seeAlso}
isReadable()。
\end{seeAlso}

bool QMetaProperty::isWritable() const

若该属性可被写入则返回 true，否则返回 false。

\begin{seeAlso}
isReadable() 和 write()。
\end{seeAlso}

const char *QMetaProperty::name() const

返回本属性的名称。

\begin{seeAlso}
type() 和 typeName()。
\end{seeAlso}

QMetaMethod QMetaProperty::notifySignal() const

若已为本属性指定数值修改时发送的通知信号，则返回该通知信号对应的 QMetaMethod 实例，否则返回无效的 QMetaMethod 对象。

本函数在 Qt 4.5 中被引入。

\begin{seeAlso}
hasNotifySignal()。
\end{seeAlso}

int QMetaProperty::notifySignalIndex() const

若已为本属性指定数值修改时发送的通知信号，则返回该通知信号的索引编号，否则返回 -1。

本函数在 Qt 4.6 中被引入。

\begin{seeAlso}
hasNotifySignal()。
\end{seeAlso}

int QMetaProperty::propertyIndex() const

返回本属性的索引编号。

本函数在 Qt 4.6 中被引入。

QVariant QMetaProperty::read(const QObject *object) const

读取给定的 object 中的本属性，若可以读取则返回属性值，否则返回无效的 QVariant。

\begin{seeAlso}
write()，reset() 和 isReadable()。
\end{seeAlso}

QVariant QMetaProperty::readOnGadget(const void *gadget) const

读取给定的 gadget 中的本属性，若可以读取则返回属性值，否则返回无效的 QVariant。

当且仅当本属性是 Q\_GADGET 中的属性时，才可使用此函数。

本函数在 Qt 5.5 中被引入。

int QMetaProperty::relativePropertyIndex() const

返回本属性在对应的元对象中的相对索引编号。

本函数在 Qt 5.14 中被引入。

bool QMetaProperty::reset(QObject *object) const

通过重置方法重置给定的 object 中的本属性。若重置成功则返回 true，否则返回 false。

重置方法是可选的，只有少量属性支持重置。

\begin{seeAlso}
read() 和 write()。
\end{seeAlso}

bool QMetaProperty::resetOnGadget(void *gadget) const

通过重置方法重置给定的 gadget 中的本属性。若重置成功则返回 true，否则返回 false。

重置方法是可选的，只有少量属性支持重置。

当且仅当本属性是 Q\_GADGET 中的属性时，才可使用此函数。

本函数在 Qt 5.5 中被引入。

int QMetaProperty::revision() const

若该属性被 REVISION 标记，则返回对应的版本，否则返回 0。

本函数在 Qt 5.1 中被引入。

QVariant::Type QMetaProperty::type() const

返回本属性的类型。返回值是 QVariant::Type 的枚举值之。

\begin{seeAlso}
userType()，typeName() 和 name()。
\end{seeAlso}

const char *QMetaProperty::typeName() const

返回本属性的类型名称。

\begin{seeAlso}
type() 和 name()。
\end{seeAlso}

int QMetaProperty::userType() const

返回本属性的用户类型。返回值是 QMetaType 中注册的类型之一，若该类型未被注册则返回 QMetaType::UnknownType。

本函数在 Qt 4.2 中被引入。

\begin{seeAlso}
type()，QMetaType 和 typeName()。
\end{seeAlso}

bool QMetaProperty::write(QObject \emph{*object}, const QVariant \emph{\&value}) const

将 value 写入到给定的 object 的本属性中，若写入成功则返回 true，否则返回 false。

若 value 与本属性类型不一致，则会尝试进行自动转换。若本属性是可重置的，则传入空的 QVariant() 等价于调用 reset()，否则等价于设置为默认值。

\begin{seeAlso}
read()，reset() 和 isWritable()。
\end{seeAlso}

bool QMetaProperty::writeOnGadget(void \emph{*gadget}, const QVariant \emph{\&value}) const

将 value 写入到给定的 gadget 的本属性中，若写入成功则返回 true，否则返回 false。

当且仅当本属性是 Q\_GADGET 中的属性时，才可使用此函数。

本函数在 Qt 5.5 中被引入。
>>>>>>> dev
