\chapter{QSerialPort}

QSerialPort 类用于访问串口。更多内容...

\begin{tabular}{|r|l|}
	\hline
	属性 & 方法 \\
	\hline
	头文件 & \#include <QSerialPort>\\      
	\hline
	qmake & QT += serialport\\      
	\hline
	父类: & QIODevice \\
	\hline
\end{tabular}

\begin{compactitem}
\item 列出所有成员, 包括子类成员
\item 废弃的类
\end{compactitem}

\begin{notice}
该类中的所有函数均为 reentrant。
\end{notice}

\section{公共成员类型}

\begin{longtable}{|r|m{30em}|}
	\hline 
	类型	& 方法 \\ 
	\hline 
	enum &	BaudRate \{Baud1200, Baud2400, Baud4800, Baud9600, Baud19200, …, UnknownBaud \} \\ 
	\hline
	enum &	DataBits \{ Data5, Data6, Data7, Data8, UnknownDataBits \} \\ 
	\hline
	enum &	Direction \{ Input, Output, AllDirections \} \\ 
	\hline 
	flags& ParamType	Directions \\ 
	\hline 
	enum&	FlowControl \{ NoFlowControl, HardwareControl, SoftwareControl, UnknownFlowControl \} \\ 
	\hline
	enum&	DataBitsParity \{ NoParity, EvenParity, OddParity, SpaceParity, MarkParity, UnknownParity \} \\ 
	\hline
	enum&	PinoutSignal \{ NoSignal, TransmittedDataSignal, ReceivedDataSignal, DataTerminalReadySignal, DataCarrierDetectSignal, …, SecondaryReceivedDataSignal \}\\ 
     \hline 
	flags&	PinoutSignals \\ 
	\hline
	enum&	SerialPortError \{ NoError, DeviceNotFoundError, PermissionError, OpenError, NotOpenError, …, UnknownError \} \\ 
	\hline
	enum&	StopBits \{ OneStop, OneAndHalfStop, TwoStop, UnknownStopBits \} \\ 
	\hline
\end{longtable}


\section{属性}

\begin{tabular}{|r|l|}
\hline
属性名	& 类型  \\
\hline
baudRate &	qint32 \\ 
\hline
breakEnabled	&bool \\ 
\hline
dataBits&	dataBits \\ 
\hline
dataTerminalReady	&bool \\ 
\hline
error&	SerialPortError \\ 
\hline
flowControl&	FlowControl \\ 
\hline
parity	&Parity \\ 
\hline
requestToSend&	bool \\ 
\hline
stopBits	&StopBits \\ 
\hline
\end{tabular}

\section{公共成员函数}

\begin{longtable}{|r|m{25em}|}
\hline
返回类型&	函数名 \\ 
\hline
&QSerialPort(const QSerialPortInfo \&serialPortInfo, QObject *parent = nullptr) \\
\hline
&QSerialPort(const QString \&name, QObject *parent = nullptr) \\ 
\hline
&[QSerialPort](QObject *parent = nullptr) \\ 
\hline
virtual&	$\sim$QSerialPort() \\ 
\hline
qint32&	baudRate(QSerialPort::Directions directions = AllDirections) const \\ 
\hline
bool&	clear(QSerialPort::Directions directions = AllDirections) \\ 
\hline
void&	clearError() \\ 
\hline
QSerialPort::DataBits&	dataBits() const \\ 
\hline
QSerialPort::SerialPortError&	error() const \\ 
\hline
QSerialPort::FlowControl&	flowControl() const \\ 
\hline
bool&	flush() \\ 
\hline
QSerialPort::Handle	&handle() const \\ 
\hline
bool&	isBreakEnabled() const \\ 
\hline
bool&	isDataTerminalReady()  \\ 
\hline
bool&	isRequestToSend() \\ 
\hline
QSerialPort::Parity	&parity() const \\ 
\hline
QSerialPort::PinoutSignals	&pinoutSignals() \\ 
\hline
QString	&portName() const \\ 
\hline
qint64	&readBufferSize() const \\ 
\hline
bool	&sendBreak(int duration = 0) \\ 
\hline
bool	&setBaudRate(qint32 baudRate, QSerialPort::Directions directions = AllDirections) \\ 
\hline
bool	&setBreakEnabled(bool set = true) \\ 
\hline
bool	&setDataBits(QSerialPort::DataBits dataBits) \\ 
\hline
bool	&setDataTerminalReady(bool set) \\ 
\hline
bool	&setFlowControl(QSerialPort::FlowControl flowControl) \\ 
\hline
bool	&setParity(QSerialPort::Parity parity) \\ 
\hline
void	&setPort(const QSerialPortInfo \&serialPortInfo) \\ 
\hline
void	&setPortName(const QString \&name) \\ 
\hline
void	&setReadBufferSize(qint64 size) \\ 
\hline
bool	&setRequestToSend(bool set) \\ 
\hline
bool	&setStopBits(QSerialPort::StopBits stopBits) \\ 
\hline
QSerialPort::StopBits &	stopBits() const \\ 
\hline
\end{longtable}


\section{重写公共成员函数}

\begin{longtable}{|r|m{25em}|}
	\hline
	返回类型&	函数名 \\ 
	\hline
	virtual bool 	&atEnd() const override \\ 
	\hline
virtual qint64&	bytesAvailable() const override \\ 
\hline
virtual qint64&	bytesToWrite() const override \\ 
\hline
virtual bool&	canReadLine() const override \\ 
\hline
virtual void&	close() override \\ 
\hline
virtual bool	&isSequential() const override \\ 
\hline
virtual bool&	open(QIODevice::OpenMode mode) override \\ 
\hline
virtual bool&	waitForBytesWritten(int msecs = 30000) override \\ 
\hline
virtual bool&	waitForReadyRead(int msecs = 30000) override \\
	\hline
\end{longtable}


\section{信号}

\begin{longtable}{|r|l|}
\hline
返回类型&	函数名 \\ 
\hline
void	&baudRateChanged(qint32 baudRate, QSerialPort::Directions directions) \\ 
\hline
void	&breakEnabledChanged(bool set) \\ 
\hline
void	&dataBitsChanged(QSerialPort::DataBits dataBits) \\ 
\hline
void	&dataTerminalReadyChanged(bool set) \\ 
\hline
void	&errorOccurred(QSerialPort::SerialPortError error) \\  
\hline
void&	flowControlChanged(QSerialPort::FlowControl flow) \\ 
\hline
void&	parityChanged(QSerialPort::Parity parity) \\ 
\hline
void&	requestToSendChanged(bool set) \\ 
\hline
void&	stopBitsChanged(QSerialPort::StopBits stopBits) \\ 
\hline
\end{longtable}

\section{重写保护成员函数}

\begin{tabular}{|r|l|}
\hline
返回类型&	函数名 \\ 
\hline
virtual qint64&	readData(char \emph{*data}, qint64 \emph{maxSize}) override \\
\hline
virtual qint64&	readLineData(char \emph{*data}, qint64 \emph{maxSize}) override \\ 
\hline
virtual qint64&	writeData(const char \emph{*data}, qint64 \emph{maxSize}) override \\ 
\hline
\end{tabular}



\section{详细描述}

您可以使用 QSerialPortInfo 帮助类来获取可用串口的信息，这个类可以枚举系统中的所有串口，当您想使用某个串口时，使用这个类可以获得正确的串口名。可以通过把 QSerialPortInfo 类实例对象作为参数传递给 setPort() 或 setPortName() 方法来指定串口设备。

串口设置完毕以后，可以使用 open() 方法以只读 (r/o)、只写 (w/o)、读写 (r/w) 模式打开串口。

\begin{notice}
串口总是以独占访问的方式打开，即其它进程或线程无法访问已经打开的串口。
\end{notice}

请使用 close() 方法来关闭串口或取消串口读写操作。

串口打开以后，QSerialPort 会检查串口当前的配置并初始化。
您可以使用 setBaudRate(), setDataBits(), setParity(), setStopBits(), 和 setFlowControl() 方法重新配置串口。

QSerialPort::dataTerminalReady 和 QSerialPort::requestToSend 属性用来设置串口引脚信号，还可以使用 pinoutSignals() 方法来查询串口引脚信号。

当串口准备好时，可以用 read() 或 write() 方法来读写串口。
您还可以使用 readLine() 和 readAll() 这样的便捷方法读写串口。
如果数据没有一次读完，剩下的数据会被接下来有新数据被添加至 QSerialPort 内部读缓冲器时再读出。
您可以使用 setReadBufferSize() 方法来设置串口读缓冲区的大小。

QSerialPort 提供了一组函数来暂停线程调用直到触发特定的信号。这些函数可以用来阻塞串口：

\begin{compactitem}
\item waitForReadyRead() 函数阻塞线程调用直到串口有新数据准备读出
\item waitForBytesWritten() 函数阻塞线程调用直到有新数据被写进串口
\end{compactitem}

阻塞串口代码示例：

\begin{cppcode}
int numRead = 0, numReadTotal = 0;
char buffer[50];

for (;;) {
    numRead  = serial.read(buffer, 50);

    // Do whatever with the array

    numReadTotal += numRead;
    if (numRead == 0 && !serial.waitForReadyRead())
        break;
}
\end{cppcode}

如果 waitForReadyRead() 返回 false，说明串口连接已经关闭或者有错误出现。

如果串口出现错误，QSerialPort 将会发射 errorOccurred() 信号。
您还可以调用 error() 方法来查询串口最近一次出现错误的类型。

\begin{notice}
在 QSerialPort 中，并非所有的错误都是以操作系统平台无关的方式处理。
诸如帧、奇偶校验、终止条件这样的错误需要由应用程序代码来处理，可能需要使用设备描述符中的操作系统相关的 ioctls 和(或)解析串口数据流中的字节填充。
\end{notice}

编程阻塞串口与编程非阻塞串口完全不同。阻塞串口不需要事件循环，通常会让编程更简单。
然而，在图形用户界面程序中，阻塞串口应该仅用于非图形用户界面线程，这样做可以避免用户界面卡顿。

若想更深入了解这方面内容，请参考 example 中的例程。

QSerialPort 类还可以与 QTextStream 和 QDataStream 的流运算符(<<()和>>())一起使用。
有一点需要注意：在使用流运算符 >>() 之前请确保串口缓冲区有足够多的数据可读。

\begin{seeAlso}
QSerialPortInfo。
\end{seeAlso}

\section{成员类型文档}

enum QSerialPort::BaudRate

该枚举描述了串口通信波特率。

\begin{notice}
该枚举仅列出了最常用的串口通信波特率。
\end{notice}


\begin{longtable}{|r|c|m{20em}|}
\hline
常量	&值&	描述 \\ 
\hline
QSerialPort::Baud1200 &	1200&	1200 比特/秒 \\ 
\hline
QSerialPort::Baud2400	&2400&	2400 比特/秒 \\ 
\hline
QSerialPort::Baud4800	&4800&	4800 比特/秒 \\ 
\hline
QSerialPort::Baud9600	&9600&	9600 比特/秒 \\ 
\hline
QSerialPort::Baud19200	&19200&	19200 比特/秒 \\ 
\hline
QSerialPort::Baud38400	&38400	&38400 比特/秒 \\ 
\hline
QSerialPort::Baud57600	&57600	&57600 比特/秒 \\ 
\hline
QSerialPort::Baud115200&	115200&	115200 比特/秒 \\ 
\hline
QSerialPort::UnknownBaud	&-1	&波特率未知。这个值已经废弃了。此处保留是为了兼容旧的代码。
 强烈建议您在新开发的代码中不使用这个值 \\ 
\hline
\end{longtable}

\begin{seeAlso}
QSerialPort::baudRate。
\end{seeAlso}

enum QSerialPort::DataBits

该枚举描述了每个字符所使用的数据比特数。

\begin{longtable}{|r|c|m{20em}|}
\hline
常量	&值&	描述 \\ 
\hline 
QSerialPort::Data5 &	5&	每个字符用5比特表示，用于波特码，常见于旧式设备，例如电传打字机 \\ 
\hline
QSerialPort::Data6	&6&	每个字符用6比特表示，很少这样用 \\ 
\hline
QSerialPort::Data7&	7&	每个字符用7比特表示，用于ASCII码，常见于旧式设备，例如电传打字机 \\ 
\hline
QSerialPort::Data8	&8	&每个字符用8比特表示，大部分数据采用此格式，因为1个字节包含8比特。它在新应用中广泛使用 \\ 
\hline
QSerialPort::UnknownDataBits&	-1&	比特数未知。这个值已经废弃了。此处保留是为了兼容旧的代码。强烈建议您在新开发的代码中不使用这个值 \\ 
	\hline
\end{longtable}

\begin{seeAlso}
QSerialPort::dataBits。
\end{seeAlso}

enum QSerialPort::Direction

flags QSerialPort::Directions

该枚举描述了串口数据传输方向。

\begin{notice}
在某些操作系统中(例如类 POSIX 系统)，该枚举对串口的输入/输出波特率单独设置。
\end{notice}

\begin{tabular}{|r|c|l|}
\hline
常量	&值&	描述 \\ 
\hline 
QSerialPort::Input	& 1 &	输入方向 \\ 
\hline
QSerialPort::Output	 &2	 &输出方向 \\ 
\hline
QSerialPort::AllDirections&	Input&	Output \\
\hline
\end{tabular}


方向类型是 QFlags 的类型定义(typedef)，它保存了方向值的 OR 组合。

enum QSerialPort::FlowControl

该枚举描述了串口使用的流控制方式。

\begin{tabular}{|r|c|m{20em}|}
\hline
常量	&值&	描述 \\ 
\hline 
QSerialPort::NoFlowControl&	0	&没有流控制 \\ 
\hline
QSerialPort::HardwareControl&	1&	硬件流控制 (RTS/CTS) \\ 
\hline
QSerialPort::SoftwareControl&	2	&软件流控制 (XON/XOFF) \\ 
\hline
QSerialPort::UnknownFlowControl	&-1 &	流控制未知。这个值已经废弃了。此处保留是为了兼容旧的代码。强烈建议您在新开发的代码中不使用这个值 \\ 
\hline
\end{tabular}

\begin{seeAlso}
QSerialPort::flowControl。
\end{seeAlso}

enum QSerial::Parity

该枚举描述了串口使用的奇偶校验模式。

\begin{tabular}{|r|c|m{22em}|}
\hline
常量	&值&	描述 \\ 
\hline 
QSerialPort::NoParity	&0&	没有奇偶校验。这是最常见的奇偶校验设置。错误检测由通信协议完成 \\ 
\hline 
QSerialPort::EvenParity&	2	&每个字符包含1比特奇偶校验，字符比特数为偶数(含奇偶校验位) \\ 
\hline
QSerialPort::OddParity&	3	&每个字符包含1比特奇偶校验，字符比特数为奇数(含奇偶校验位)。它确保了每个字符至少有一次状态转换 \\ 
\hline
QSerialPort::SpaceParity&	4	&间隔奇偶校验。奇偶校验位在间隔信号中发送。它不提供错误检测信息 \\ 
\hline
QSerialPort::MarkParity	&5&	标志奇偶校验。奇偶校验位总是被置为标志信号(逻辑 1)。它不提供错误检测信息 \\ 
\hline
QSerialPort::UnknownParity&	-1	&奇偶校验未知。这个值已经废弃了。此处保留是为了兼容旧的代码。强烈建议您在新开发的代码中不使用这个值 \\ 
\hline
\end{tabular}

\begin{seeAlso}
QSerialPort::parity。
\end{seeAlso}

enum QSerialPort::PinoutSignal

flags QSerialPort::PinoutSignals

该枚举用于描述串口引脚信号。

\begin{longtable}{|r|c|m{9em}|}
\hline
常量	&值&	描述 \\ 
\hline 
QSerialPort::NoSignal	&0x00&	无信号 \\ 
\hline
QSerialPort::TransmittedDataSignal&	0x01&	TxD (发送数据)。这个值已经废弃了。此处保留是为了兼容旧的代码。强烈建议您在新开发的代码中不使用这个值 \\
\hline
QSerialPort::ReceivedDataSignal	&0x02	&RxD (接收数据)。这个值已经废弃了。此处保留是为了兼容旧的代码。强烈建议您在新开发的代码中不使用这个值\\
\hline
QSerialPort::DataTerminalReadySignal	&0x04&	DTR (数据终端就绪) \\ 
\hline
QSerialPort::DataCarrierDetectSignal	&0x08&	DCD (数据载波检测) \\ 
\hline
QSerialPort::DataSetReadySignal	&0x10	&DSR (数据就绪) \\ 
\hline
QSerialPort::RingIndicatorSignal&	0x20&	RNG (振铃提示) \\ 
\hline
QSerialPort::RequestToSendSignal	&0x40&	RTS (请求发送) \\ 
\hline
QSerialPort::ClearToSendSignal	&0x80&	CTS (清除发送) \\
\hline 
QSerialPort::SecondaryTransmittedDataSignal	&0x100&	STD (辅助发送数据) \\
\hline
QSerialPort::SecondaryReceivedDataSignal&	0x200	&SRD (辅助接收数据) \\ 
\hline
\end{longtable}

PinoutSignals类型是 QFlags 的类型定义(typedef)，它保存了PinoutSignal值的 OR 组合。

\begin{seeAlso}
pinoutSignals(), QSerialPort::dataTerminalReady, 和 QSerialPort::requestToSend。
\end{seeAlso}

enum QSerialPort::SerialPortError

该枚举描述了 QSerialPort::error 属性的错误类型。

\begin{longtable}{|r|c|m{9em}|}
	\hline
	常量	&值&	描述 \\ 
	\hline 
	QSerialPort::NoError &	0 &	没有错误 \\ 
	\hline
	QSerialPort::DeviceNotFoundError &	1 &	尝试打开一个不存在的串口设备 \\ 
	\hline
	QSerialPort::PermissionError 	&2 	&其它进程试图打开一个已经开启的串口设备或者用户没有足够的权限打开串口 \\ 
	\hline
	QSerialPort::OpenError &	3& 	在当前对象中试图打开一个已经开启的串口 \\ 
	\hline
	QSerialPort::NotOpenError 	&13 &	在串口未开启时执行某个操作。这个值从 QtSerialPort 5.2 开始使用 \\
	\hline 
	QSerialPort::ParityError &	4 &	读串口时硬件检测到奇偶校验错误。这个值已经废弃了。强烈建议您在新开发的代码中不使用这个值 \\ 
	\hline
	QSerialPort::FramingError &	5 &	读串口时硬件检测到帧错误。这个值已经废弃了。强烈建议您在新开发的代码中不使用这个值 \\ 
	\hline
	QSerialPort::BreakConditionError &	6 &	串口输入线上检测到终止条件。这个值已经废弃了。强烈建议您在新开发的代码中不使用这个值 \\ 
	\hline
	QSerialPort::WriteError &	7 	&写串口时出现的 I/O 错误 \\ 
	\hline
	QSerialPort::ReadError &	8 &	读串口时出现的 I/O 错误 \\ 
\hline
	QSerialPort::ResourceError 	&9 	&当资源无法访问时出现的 I/O 错误。例如：当串口设备意外断开时 \\ 
	\hline
	QSerialPort::UnsupportedOperationError& 	10 &	操作系统禁止或不支持请求的串口操作 \\ 
	\hline
	QSerialPort::TimeoutError 	&12 &	超时错误。这个值从 QtSerialPort 5.2 开始使用 \\ 
	\hline
	QSerialPort::UnknownError &	11 &	未知错误 \\ 
	\hline
\end{longtable}


enum QSerialPort::StopBits

该枚举描述了串口停止位的比特数。

\begin{tabular}{|r|c|m{15em}|}
	\hline
	常量	&值&	描述 \\ 
	\hline 
	QSerialPort::OneStop 	&1& 	1比特停止位 \\ 
	\hline
	QSerialPort::OneAndHalfStop &	3 &	1.5比特停止位(仅适用于Windows系统) \\ 
	\hline
	QSerialPort::TwoStop &	2 	&2比特停止位 \\ 
	\hline
	QSerialPort::UnknownStopBits &	-1& 	停止位比特数未知。这个值已经废弃了。此处保留是为了兼容旧的代码。强烈建议您在新开发的代码中不使用这个值 \\ 
   \hline
\end{tabular}

\begin{seeAlso}
QSerialPort::stopBits。
\end{seeAlso}

\section{成员属性文档}


baudRate : qint32

该属性为串口在指定方向(输入/输出)上的通信波特率。

如果串口波特率设置成功或者打开串口前设置好波特率，那么返回true，否则返回false并且把错误码置1。该错误码可以通过读取 QSerialPort::error 属性的值获得。您可以使用枚举 QSerialPort::BaudRate 或者任何 qint32 型正整数值设置串口通信波特率。

\begin{notice}
如果在打开串口前设置该属性，那么真实的串口设置将会在串口打开后，在 QSerialPort::open() 方法中自动完成。
\end{notice}

\begin{warning}
所有操作系统均支持 AllDirections 标志位设置，但 Windows 系统仅支持这种模式。
\end{warning}

\begin{warning}
在 Windows 系统中无论串口输入还是输出，其波特率均相同。
\end{warning}

该属性的默认值为 Baud9600，即 9600 比特/秒。

存取函数:

\begin{tabular}{|r|m{25em}|}
\hline
返回类型 &	函数名 \\ 
\hline
qint32 	&baudRate(QSerialPort::Directions \emph{directions} = AllDirections) const \\ 
\hline
bool 	&setBaudRate(qint32 baudRate, QSerialPort::Directions \emph{directions} = AllDirections) \\ 
\hline
\end{tabular} 

通知信号:

\begin{tabular}{|r|m{25em}|}
\hline
返回类型 &	函数名 \\
\hline
void 	& baudRateChanged(qint32 baudRate, QSerialPort::Directions directions) \\ 
\hline
\end{tabular} 

breakEnabled : bool

该属性为串口是否终止传输的标志位。

若串口终止通信，则该属性为 true，否则为 false。

注意: 在设置或访问该属性前串口必须已经打开，否则返回 false 并且 NotOpenError 错误码将被置 1。这一点与常规的 Qt 类属性设置不同。然而，这种差异性源于该属性是通过操作系统内核与串口硬件之间的交互来设置的，因此 Qt 串口类属性与其它 Qt 类属性不完全等同。

该属性从 Qt 5.5 开始使用。

存取函数:

\begin{tabular}{|r|l|}
\hline
返回类型 	& 函数名 \\ 
\hline 
bool 	&isBreakEnabled() const \\ 
\hline
bool &	setBreakEnabled(bool set = true) \\ 
\hline
\end{tabular}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

通知信号:

\begin{tabular}{|r|l|}
\hline
返回类型  &	函数名 \\ 
\hline
void &	breakEnabledChanged(bool set) \\ 
\hline
\end{tabular}

dataBits : DataBits 

该属性为串口数据帧中的比特数。

若设置成功或者打开串口前设置好该属性，那么返回true，否则返回false并且把错误码置1。该错误码可以通过读取 QSerialPort::error 属性的值获得。

注意: 如果在打开串口前设置该属性，那么真实的串口设置将会在串口打开后，在 QSerialPort::open() 方法中自动完成。

该属性的默认值为 Data8，即数据帧为8比特。

存取函数:

\begin{tabular}{|r|l|}
\hline
返回类型  &	函数名 \\ 
\hline
QSerialPort::DataBits  &	dataBits() const \\
\hline
bool &	setDataBits(QSerialPort::DataBits dataBits) \\ 
\hline
\end{tabular}

通知信号:

\begin{tabular}{|r|l|}
	\hline
	返回类型  &	函数名 \\ 
	\hline
	void 	& dataBitsChanged(QSerialPort::DataBits dataBits) \\ 
	\hline
\end{tabular}

dataTerminalReady : bool

该属性为串口信号线 DTR 的状态(高或低)。

如果串口信号线 DTR 被置为高电平，则返回true，否则返回false.

注意: 在设置或访问该属性前串口必须已经打开，否则返回 false 并且 NotOpenError 错误码将被置 1。

存取函数:

\begin{tabular}{|r|l|}
\hline
返回类型  &	函数名 \\ 
\hline
bool &	isDataTerminalReady() \\ 
\hline
bool &	setDataTerminalReady(bool set) \\ 
\hline
\end{tabular}
 
通知信号:

\begin{tabular}{|r|l|}
	\hline
	返回类型  &	函数名 \\ 
	\hline
	void 	& dataTerminalReadyChanged(bool set) \\ 
	\hline
\end{tabular}

另请参阅 pinoutSignals()。

error : SerialPortError

该属性为串口的错误码。

串口设备会返回一个错误码。
例如：如果函数 open() 返回false，或者读/写操作返回-1，该属性可以用来判断操作失败的原因。

当调用clearError()函数后，错误码会被置为默认值 QSerialPort::NoError.

存取函数:

\begin{tabular}{|r|l|}
	\hline
	返回类型  &	函数名 \\ 
	\hline
	QSerialPort::SerialPortError 	&error() const \\ 
	\hline
void 	&clearError() \\ 
	\hline
\end{tabular}



flowControl : FlowControl

该属性为串口使用的流控制方式。

若设置成功或者打开串口前设置好该属性，那么返回true，否则返回false并且把错误码置1。该错误码可以通过读取 QSerialPort::error 属性的值获得。

注意: 如果在打开串口前设置该属性，那么真实的串口设置将会在串口打开后，在 QSerialPort::open() 方法中自动完成。

该属性的默认值为 NoFlowControl，即没有流控制。

存取函数:

\begin{tabular}{|r|l|}
	\hline
返回类型 &	函数名 \\ 
\hline
QSerialPort::FlowControl &	flowControl() const \\ 
\hline
bool &	setFlowControl(QSerialPort::FlowControl flowControl) \\ 
\hline
\end{tabular}


通知信号:

\begin{tabular}{|r|l|}
\hline
返回类型 &函数名 \\ 
\hline
void 	&flowControlChanged(QSerialPort::FlowControl flow) \\ 
\hline
\end{tabular}

parity : Parity 

该属性为串口使用的奇偶校验模式。

若设置成功或者打开串口前设置好该属性，那么返回true，否则返回false并且把错误码置1。该错误码可以通过读取 QSerialPort::error 属性的值获得。

\begin{notice}
如果在打开串口前设置该属性，那么真实的串口设置将会在串口打开后，在 QSerialPort::open() 方法中自动完成。
\end{notice}

该属性的默认值为 NoParity，即没有奇偶校验。

存取函数:

\begin{tabular}{|r|l|}
\hline
返回类型 &函数名 \\ 
\hline
QSerialPort::Parity &	parity() const \\
\hline
bool &	setParity(QSerialPort::Parity parity) \\ 
\hline
\end{tabular}

通知信号:

\begin{tabular}{|r|l|}
	\hline
	返回类型 &函数名 \\ 
	\hline
	void 	& parityChanged(QSerialPort::Parity parity) \\
\hline
\end{tabular}


requestToSend : bool

该属性为串口信号线 RTS 的状态(高或低)。

如果串口信号线 RTS 被置为高电平，则返回true，否则返回false.

\begin{notice}
在设置或访问该属性前串口必须已经打开，否则返回 false 并且 NotOpenError 错误码将被置 1。
\end{notice}

\begin{notice}
在 HardwareControl 模式下直接控制 RTS 信号会出错， 错误码 UnsupportedOperationError 会被置1，因为 RTS 信号由驱动自动控制。
\end{notice}

存取函数:

\begin{tabular}{|r|l|}
\hline
返回类型 &	函数名 \\ 
\hline
bool &	isRequestToSend() \\ 
\hline
bool 	& setRequestToSend(bool set) \\ 
\hline
\end{tabular}