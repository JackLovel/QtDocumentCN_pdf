\chapter{const\_iterator}

const\_iterator 类

class QHash::const\_iterator

QHash::const\_iterator 类为 QHash\ref{hash} 和 QMultiHash 提供 STL 风格的常量迭代器。\href{https://github.com/JackLovel/QtDocumentCN/blob/master/Src/H/QHash/QHash-const-iterator.md#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0}{更多内容...}

\begin{itemize}
\item 所有成员列表，包括继承的成员
\item 废弃的成员
\end{itemize}

\splitLine

公共成员函数

\begin{tabular}{|l|l|}
\hline
类型	&函数名\\
\hline
 	&const\_iterator(const iterator \&other)\\
\hline
	&const\_iterator()\\
\hline
const Key \& &	key() const\\
\hline
const T \& &	value() const\\
\hline
bool &	operator!=(const const\_iterator \&other) const\\
\hline
const T \& &	operator*() const\\
\hline
const\_iterator \& &	operator++()\\
\hline
const\_iterator 	&operator++(int)\\
\hline
const T * 	&operator->() const\\
\hline
bool 	&operator==(const const\_iterator \&other) const\\
\hline
\end{tabular}


\splitLine

详细描述

QHash 同时提供 STL 风格迭代器 和 Java 风格迭代器。STL 风格迭代器更底层，使用更笨拙；同时也稍快一些。对于已经了解 STL 的开发者来说更加熟悉。

QHash<Key, T>::const\_iterator 用来遍历 QHash（或 QMultiHash）。如果想在遍历时修改 QHash，必须使用 QHash::iterator。对于非常量 QHash，使用 QHash::const\_iterator 通常也是好的编程实践，除非需要在遍历时改变 QHash。const 迭代器稍快一些并可以提高代码可读性。

QHash::const\_iterator 的默认构造函数创建一个未初始化的迭代器。必须在开
始遍历前使用 QHash::constBegin()，QHash::constEnd() 或 QHash::find()
等 QHash 函数初始化它。下面是一个典型的循环，该循环打印出 map 中的所有
键值对：

\begin{lstlisting}[language=C++]
QHash<QString, int> hash;
hash.insert("January", 1);
hash.insert("February", 2);
...
hash.insert("December", 12);

QHash<QString, int>::const_iterator i;
for (i = hash.constBegin(); i != hash.constEnd(); ++i)
    cout << i.key() << ": " << i.value() << Qt::endl;
\end{lstlisting}

与通过键的大小有序存储元素的 QMap 不同，QHash 无序存储元素。唯一的保证是共享同一键的元素（通过 QMultiHash 的函数插入）将按照从最新到最早插入值的顺序连续出现。

同一哈希表可以使用多个迭代器。然而，需要注意任何对 QHash 的直接修改都可能完全改变哈希表中存储的元素顺序，因为该操作可能引起 QHash 重新散列其内部数据结构。如果需要长时间持有迭代器，建议使用 QMap 而非 QHash。

\textbf{警告}： 隐式共享容器迭代器的工作方式和 STL 迭代器不完全相同。当容器的迭代器还处于活动状态时，应该避免拷贝容器。更多信息请参阅隐式共享迭代器问题。

\textbf{另请参阅}: QHash::iterator 和 QHashIterator。


\splitLine

成员函数文档

const\_iterator::const\_iterator(const iterator \&other)

构造一个 \emph{other} 的副本。

const\_iterator::const\_iterator()

构造一个未初始化的迭代器。

一定不要对未初始化的迭代器调用 key()，value() 和 operator++() 等函数。使用前要用 operator=() 赋值。

\textbf{另请参阅}: QHash::constBegin() 和 QHash::constEnd()。

const Key \&const\_iterator::key() const

返回当前元素的键。

\textbf{另请参阅}: value()。

const T \&const\_iterator::value() const

返回当前元素的值。

\textbf{另请参阅}: key() 和 operator*()。

bool const\_iterator::operator!=(const const\_iterator \&other) const

如果 other 与本迭代器指向的元素不同，返回 \hl{true}；否则返回 \hl{false}。

\textbf{另请参阅}: operator==()。

const T \&const\_iterator::operator*() const

返回当前元素的值。

同 value()。

\textbf{另请参阅}: key()。

const\_iterator \&const\_iterator::operator++()

前置 ++ 运算符（\hl{++i}）将迭代器向前移动到哈希表中的下一个元素并返回指向新位置元素的迭代器。

对 QHash::end() 调用该函数将导致未定义结果。

\textbf{另请参阅}: operator--()。

const\_iterator const\_iterator::operator++(int)

这是一个重载函数。

后置 ++ 运算符（\hl{i++}）将迭代器向前移动到哈希表中的下一个元素并返回指向
旧位置元素的迭代器。

const T *const\_iterator::operator->() const

返回指向当前元素值的指针。

\textbf{另请参阅}: value()。

bool const\_iterator::operator==(const const\_iterator \&other) const

如果 other 与本迭代器指向相同的元素，返回 \hl{true}；否则返回 \hl{false}。

\textbf{另请参阅}: operator!=()。


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../master"
%%% End: