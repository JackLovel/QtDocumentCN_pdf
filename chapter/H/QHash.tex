\chapter{QHash}\label{hash}

template <typename Key, typename T> class QHash

QHash 类是一种模板类，提供基于哈希表的字典类结构。更多内容...\ref{detail}


\begin{tabular}{|l|l|}
\hline
属性& 	内容\\
\hline
头文件& 	\hl{\#include <QHash>}\\
\hline
qmake& 	\hl{QT += core}\\
\hline
派生类& 	QMultiHash\\
\hline
\end{tabular}


\begin{itemize}
\item 所有成员列表，包括继承的成员
\item 废弃的成员
\end{itemize}

\textbf{注意}： 该类中的所有函数都是可重入的。

\splitLine

\section{公共成员类型}

\begin{tabular}{|m{5em}|m{30em}|}
\hline
class& 	const\_iterator\\
\hline
class& 	iterator\\
\hline
class& 	key\_iterator\\
\hline
typedef& 	ConstIterator\\
\hline
typedef& 	Iterator\\
\hline
typedef& 	const\_key\_value\_iterator\\
\hline
typedef& 	difference\_type\\
\hline
typedef& 	key\_type\\
\hline
typedef& 	key\_value\_iterator\\
\hline
typedef& 	mapped\_type\\
\hline
typedef& 	size\_type\\
\hline
\end{tabular}

\splitLine

\section{公共成员函数}

\begin{longtable}{|l|l|}
\hline
 	&QHash(InputIterator begin, InputIterator end)\\
\hline
	&QHash(QHash<K, V> \&\&other)\\
\hline
	&QHash(const QHash<K, V> \&other)\\
\hline
	&QHash(std::initializer\_list<std::pair<Key, T> > list)\\
\hline
	&QHash()\\
\hline
QHash<K, V> \& 	&operator=(QHash<K, V> \&\&other)\\
\hline
QHash<K, V> \& &	operator=(const QHash<K, V> \&other)\\
\hline
	&$\sim$QHash()\\
\hline
QHash::iterator 	&begin()\\
\hline
QHash::const\_iterator &	begin() const\\
\hline
int 	&capacity() const\\
\hline
QHash::const\_iterator 	&cbegin() const\\
\hline
QHash::const\_iterator &	cend() const\\
\hline
void &	clear()\\
\hline
QHash::const\_iterator& 	constBegin() const\\
\hline
QHash::const\_iterator &	constEnd() const\\
\hline
QHash::const\_iterator &	constFind(const Key \&key) const\\
\hline
QHash::const\_key\_value\_iterator& 	constKeyValueBegin() const\\
\hline
QHash::const\_key\_value\_iterator &	constKeyValueEnd() const\\
\hline
bool& 	contains(const Key \&key) const\\
\hline
int& 	count(const Key \&key) const\\
\hline
int& 	count() const\\
\hline
bool& 	empty() const\\
\hline
QHash::iterator &	end()\\
\hline
QHash::const\_iterator &	end() const\\
\hline
QPair<QHash::iterator, QHash::iterator> &	equal\_range(const Key
  \&key)\\
\hline
QPair<QHash::const\_iterator, QHash::const\_iterator> &
                                                        equal\_range(const
                                                        Key \&key)
                                                        const\\
\hline
QHash::iterator &	erase(QHash::const\_iterator pos)\\
\hline
QHash::iterator &	erase(QHash::iterator pos)\\
\hline
QHash::iterator &	find(const Key \&key)\\
\hline
QHash::const\_iterator& 	find(const Key \&key) const\\
\hline
QHash::iterator 	&insert(const Key \&key, const T \&value)\\
\hline
void& 	insert(const QHash<K, V> \&other)\\
\hline
bool &	isEmpty() const\\
\hline
const Key& 	key(const T \&value) const\\
\hline
const Key &	key(const T \&value, const Key \&defaultKey) const\\
\hline
QHash::key\_iterator &	keyBegin() const\\
\hline
QHash::key\_iterator &	keyEnd() const\\
\hline
QHash::key\_value\_iterator 	&keyValueBegin()\\
\hline
QHash::const\_key\_value\_iterator& 	keyValueBegin() const\\
\hline
QHash::key\_value\_iterator 	&keyValueEnd()\\
\hline
QHash::const\_key\_value\_iterator &	keyValueEnd() const\\
\hline
QList& 	keys() const\\
\hline
QList& 	keys(const T \&value) const\\
\hline
int &	remove(const Key \&key)\\
\hline
void &	reserve(int size)\\
\hline
int &	size() const\\
\hline
void &	squeeze()\\
\hline
void &	swap(QHash<K, V> \&other)\\
\hline
T 	&take(const Key \&key)\\
\hline
const T &	value(const Key \&key) const\\
\hline
const T &	value(const Key \&key, const T \&defaultValue) const\\
\hline
QList 	&values() const\\
\hline
bool 	&operator!=(const QHash<K, V> \emph{\&other}) const\\
\hline
bool 	&operator==(const QHash<K, V> \emph{\&other}) const\\
\hline
T \& 	&operator[](const Key \emph{\&key})\\
\hline
const T& 	operator[](const Key \emph{\&key}) const\\
\hline
\end{longtable}

\section{相关非成员函数}

\begin{longtable}{|l|l|}
\hline
类型	&函数名\\
\hline
int& 	qGlobalQHashSeed()\\
\hline
uint& 	qHash(const QSslDiffieHellmanParameters \&dhparam, uint
      seed)\\
\hline
uint& 	qHash(const QUrl \&url, uint seed = 0)\\
\hline
uint& 	qHash(const QOcspResponse \&response, uint seed)\\
\hline
uint& 	qHash(const QHash<Key, T> \&key, uint seed = 0)\\
\hline
uint& 	qHash(const QBitArray \&key, uint seed = 0)\\
\hline
uint& 	qHash(char key, uint seed = 0)\\
\hline
uint& 	qHash(const QDateTime \&key, uint seed = 0)\\
\hline
uint& 	qHash(QSslEllipticCurve curve, uint seed)\\
\hline
uint& 	qHash(QLatin1String key, uint seed = 0)\\
\hline
uint& 	qHash(uchar key, uint seed = 0)\\
\hline
uint& 	qHash(const QDate \&key, uint seed = 0)\\
\hline
uint& 	qHash(signed char key, uint seed = 0)\\
\hline
uint& 	qHash(const QTime \&key, uint seed = 0)\\
\hline
uint& 	qHash(const QSet \&key, uint seed = 0)\\
\hline
uint& 	qHash(const T *key, uint seed = 0)\\
\hline
uint& 	qHash(ushort key, uint seed = 0)\\
\hline
uint& 	qHash(short key, uint seed = 0)\\
\hline
uint& 	qHash(uint key, uint seed = 0)\\
\hline
uint& 	qHash(const QPair<T1, T2> \&key, uint seed = 0)\\
\hline
uint& 	qHash(int key, uint seed = 0)\\
\hline
uint& 	qHash(const std::pair<T1, T2> \&key, uint seed = 0)\\
\hline
uint& 	qHash(const QVersionNumber \&key, uint seed = 0)\\
\hline
uint& 	qHash(ulong key, uint seed = 0)\\
\hline
uint& 	qHash(long key, uint seed = 0)\\
\hline
uint& 	qHash(quint64 key, uint seed = 0)\\
\hline
uint& 	qHash(qint64 key, uint seed = 0)\\
\hline
uint& 	qHash(float key, uint seed = 0)\\
\hline
uint& 	qHash(double key, uint seed = 0)\\
\hline
uint& 	qHash(long double key, uint seed = 0)\\
\hline
uint& 	qHash(const Char key, uint seed = 0)\\
\hline
uint& 	qHash(const QByteArray \&key, uint seed = 0)\\
\hline
uint& 	qHash(const QString \&key, uint seed = 0)\\
\hline
uint& 	qHash(const QStringRef \&key, uint seed = 0)\\
\hline
uint& 	qHashBits(const void *p, size\_t len, uint seed = 0)\\
\hline
uint& 	qHashRange(InputIterator first, InputIterator last, uint seed = 0)\\
\hline
uint& 	qHashRangeCommutative(InputIterator first, InputIterator last, uint seed = 0)\\
\hline
void& 	qSetGlobalQHashSeed(int newSeed)\\
\hline
QDataStream \& & 	operator<<(QDataStream \&out, const QHash<Key, T> \&hash)\\
\hline
QDataStream \& &	operator>>(QDataStream \&in, QHash<Key, T> \&hash)\\
\hline
\end{longtable}

\splitLine

\section{详细描述}\label{detail}

QHash<Key, T> 是一种 Qt 泛型容器类。该类存储键值对，可以用相关联的键非常快速地查找值。

QHash 的功能与 QMap 非常相似。二者的区别在于：

\begin{itemize}
\item QHash 的查找速度比 QMap 快。（详情请看算法复杂度 。）
\item 遍历 QMap 时，元素总是按照键的顺序排好序的。而遍历 QHash时，元素的顺序是任意的。
\item QMap 的键类型必须提供 operator<() 运算符。QHash 的键类型必须提供 operator==() 运算符和名为 qHash() 的全局哈希函数 (参考 qHash 哈希函数)。
\end{itemize}

下面是一个键类型为 QString，值类型为 \hl{int} 的 QHash 的示例：

\begin{lstlisting}[language=C++]
QHash<QString, int> hash;
\end{lstlisting}


可以使用 operator 运算符将键值对插入到哈希表中：

\begin{lstlisting}[language=C++]
hash["one"] = 1;
hash["three"] = 3;
hash["seven"] = 7;
\end{lstlisting}

上面的代码将3个键值对插入到 QHash 中：("one", 1)，("three", 3) 和
("seven", 7)。另外一种向哈希表中插入元素的方法是使用 insert()：

\begin{lstlisting}[language=C++]
hash.insert("twelve", 12);
\end{lstlisting}

使用 operator 运算符或 value() 查找值：

\begin{lstlisting}[language=C++]
int num1 = hash["thirteen"];
int num2 = hash.value("thirteen");
\end{lstlisting}

如果哈希表中不存在指定的键，这些函数返回默认构造的值。

如果想检查哈希表中是否包含特定键，使用 contains()：

\begin{lstlisting}[language=C++]
int timeout = 30;
if (hash.contains("TIMEOUT"))
    timeout = hash.value("TIMEOUT");
\end{lstlisting}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../master"
%%% End: